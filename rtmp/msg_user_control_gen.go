// Automatically generated by go generate; DO NOT EDIT.

package rtmp

import (
	"encoding"
	"io"

	"github.com/pkg/errors"
	"go.uber.org/zap/zapcore"
)

type EventType uint16

const (
	EventTypeStreamBegin      EventType = 0
	EventTypeStreamEOF        EventType = 1
	EventTypeStreamDry        EventType = 2
	EventTypeSetBufferLength  EventType = 3
	EventTypeStreamIsRecorded EventType = 4
	EventTypePingRequest      EventType = 6
	EventTypePingResponse     EventType = 7
)

type UserControlMessage interface {
	encoding.BinaryMarshaler
	zapcore.ObjectMarshaler
	EventType() EventType
}

type StreamBegin interface {
	UserControlMessage
	encoding.BinaryUnmarshaler
	StreamID() uint32
}

type streamBegin struct {
	streamID uint32
}

func NewStreamBegin(
	streamID uint32,
) StreamBegin {
	return &streamBegin{
		streamID: streamID,
	}
}

func (m streamBegin) EventType() EventType {
	return EventTypeStreamBegin
}
func (m streamBegin) StreamID() uint32 {
	return m.streamID
}

func (m streamBegin) MarshalBinary() ([]byte, error) {
	b := make([]byte, 6)
	for i := range b[:2] {
		b[i] |= byte((EventTypeStreamBegin) >> (uint(1-i) * 8))
	}
	for i := range b[2:] {
		b[2+i] |= byte((m.streamID) >> (uint(3-i) * 8))
	}
	return b, nil
}

func (m *streamBegin) UnmarshalBinary(b []byte) error {
	if len(b) != 6 {
		return errors.Errorf("invalid binary size %d: %x", len(b), b)
	}
	for i, bb := range b[2:] {
		m.streamID |= uint32(bb) << (8 * uint(3-i))
	}
	return nil
}

func UnmarshalStreamBeginBinary(b []byte) (StreamBegin, error) {
	m := streamBegin{}
	err := m.UnmarshalBinary(b)
	return &m, err
}

func ReadStreamBegin(r io.Reader) (StreamBegin, error) {
	b := make([]byte, 6)
	if _, err := io.ReadFull(r, b); err != nil {
		return nil, errors.Wrap(err, "failed to read bytes")
	}
	return UnmarshalStreamBeginBinary(b)
}

func (m streamBegin) MarshalLogObject(enc zapcore.ObjectEncoder) error {
	enc.AddString("eventType", m.EventType().String())
	enc.AddUint32("streamID", m.StreamID())
	return nil
}

type StreamEOF interface {
	UserControlMessage
	encoding.BinaryUnmarshaler
	StreamID() uint32
}

type streamEOF struct {
	streamID uint32
}

func NewStreamEOF(
	streamID uint32,
) StreamEOF {
	return &streamEOF{
		streamID: streamID,
	}
}

func (m streamEOF) EventType() EventType {
	return EventTypeStreamEOF
}
func (m streamEOF) StreamID() uint32 {
	return m.streamID
}

func (m streamEOF) MarshalBinary() ([]byte, error) {
	b := make([]byte, 6)
	for i := range b[:2] {
		b[i] |= byte((EventTypeStreamEOF) >> (uint(1-i) * 8))
	}
	for i := range b[2:] {
		b[2+i] |= byte((m.streamID) >> (uint(3-i) * 8))
	}
	return b, nil
}

func (m *streamEOF) UnmarshalBinary(b []byte) error {
	if len(b) != 6 {
		return errors.Errorf("invalid binary size %d: %x", len(b), b)
	}
	for i, bb := range b[2:] {
		m.streamID |= uint32(bb) << (8 * uint(3-i))
	}
	return nil
}

func UnmarshalStreamEOFBinary(b []byte) (StreamEOF, error) {
	m := streamEOF{}
	err := m.UnmarshalBinary(b)
	return &m, err
}

func ReadStreamEOF(r io.Reader) (StreamEOF, error) {
	b := make([]byte, 6)
	if _, err := io.ReadFull(r, b); err != nil {
		return nil, errors.Wrap(err, "failed to read bytes")
	}
	return UnmarshalStreamEOFBinary(b)
}

func (m streamEOF) MarshalLogObject(enc zapcore.ObjectEncoder) error {
	enc.AddString("eventType", m.EventType().String())
	enc.AddUint32("streamID", m.StreamID())
	return nil
}

type StreamDry interface {
	UserControlMessage
	encoding.BinaryUnmarshaler
	StreamID() uint32
}

type streamDry struct {
	streamID uint32
}

func NewStreamDry(
	streamID uint32,
) StreamDry {
	return &streamDry{
		streamID: streamID,
	}
}

func (m streamDry) EventType() EventType {
	return EventTypeStreamDry
}
func (m streamDry) StreamID() uint32 {
	return m.streamID
}

func (m streamDry) MarshalBinary() ([]byte, error) {
	b := make([]byte, 6)
	for i := range b[:2] {
		b[i] |= byte((EventTypeStreamDry) >> (uint(1-i) * 8))
	}
	for i := range b[2:] {
		b[2+i] |= byte((m.streamID) >> (uint(3-i) * 8))
	}
	return b, nil
}

func (m *streamDry) UnmarshalBinary(b []byte) error {
	if len(b) != 6 {
		return errors.Errorf("invalid binary size %d: %x", len(b), b)
	}
	for i, bb := range b[2:] {
		m.streamID |= uint32(bb) << (8 * uint(3-i))
	}
	return nil
}

func UnmarshalStreamDryBinary(b []byte) (StreamDry, error) {
	m := streamDry{}
	err := m.UnmarshalBinary(b)
	return &m, err
}

func ReadStreamDry(r io.Reader) (StreamDry, error) {
	b := make([]byte, 6)
	if _, err := io.ReadFull(r, b); err != nil {
		return nil, errors.Wrap(err, "failed to read bytes")
	}
	return UnmarshalStreamDryBinary(b)
}

func (m streamDry) MarshalLogObject(enc zapcore.ObjectEncoder) error {
	enc.AddString("eventType", m.EventType().String())
	enc.AddUint32("streamID", m.StreamID())
	return nil
}

type SetBufferLength interface {
	UserControlMessage
	encoding.BinaryUnmarshaler
	StreamID() uint32
	BufferLength() uint32
}

type setBufferLength struct {
	streamID     uint32
	bufferLength uint32
}

func NewSetBufferLength(
	streamID uint32,
	bufferLength uint32,
) SetBufferLength {
	return &setBufferLength{
		streamID:     streamID,
		bufferLength: bufferLength,
	}
}

func (m setBufferLength) EventType() EventType {
	return EventTypeSetBufferLength
}
func (m setBufferLength) StreamID() uint32 {
	return m.streamID
}
func (m setBufferLength) BufferLength() uint32 {
	return m.bufferLength
}

func (m setBufferLength) MarshalBinary() ([]byte, error) {
	b := make([]byte, 10)
	for i := range b[:2] {
		b[i] |= byte((EventTypeSetBufferLength) >> (uint(1-i) * 8))
	}
	for i := range b[2:6] {
		b[2+i] |= byte((m.streamID) >> (uint(3-i) * 8))
	}
	for i := range b[6:] {
		b[6+i] |= byte((m.bufferLength) >> (uint(3-i) * 8))
	}
	return b, nil
}

func (m *setBufferLength) UnmarshalBinary(b []byte) error {
	if len(b) != 10 {
		return errors.Errorf("invalid binary size %d: %x", len(b), b)
	}
	for i, bb := range b[2:6] {
		m.streamID |= uint32(bb) << (8 * uint(3-i))
	}
	for i, bb := range b[6:] {
		m.bufferLength |= uint32(bb) << (8 * uint(3-i))
	}
	return nil
}

func UnmarshalSetBufferLengthBinary(b []byte) (SetBufferLength, error) {
	m := setBufferLength{}
	err := m.UnmarshalBinary(b)
	return &m, err
}

func ReadSetBufferLength(r io.Reader) (SetBufferLength, error) {
	b := make([]byte, 10)
	if _, err := io.ReadFull(r, b); err != nil {
		return nil, errors.Wrap(err, "failed to read bytes")
	}
	return UnmarshalSetBufferLengthBinary(b)
}

func (m setBufferLength) MarshalLogObject(enc zapcore.ObjectEncoder) error {
	enc.AddString("eventType", m.EventType().String())
	enc.AddUint32("streamID", m.StreamID())
	enc.AddUint32("bufferLength", m.BufferLength())
	return nil
}

type StreamIsRecorded interface {
	UserControlMessage
	encoding.BinaryUnmarshaler
	StreamID() uint32
}

type streamIsRecorded struct {
	streamID uint32
}

func NewStreamIsRecorded(
	streamID uint32,
) StreamIsRecorded {
	return &streamIsRecorded{
		streamID: streamID,
	}
}

func (m streamIsRecorded) EventType() EventType {
	return EventTypeStreamIsRecorded
}
func (m streamIsRecorded) StreamID() uint32 {
	return m.streamID
}

func (m streamIsRecorded) MarshalBinary() ([]byte, error) {
	b := make([]byte, 6)
	for i := range b[:2] {
		b[i] |= byte((EventTypeStreamIsRecorded) >> (uint(1-i) * 8))
	}
	for i := range b[2:] {
		b[2+i] |= byte((m.streamID) >> (uint(3-i) * 8))
	}
	return b, nil
}

func (m *streamIsRecorded) UnmarshalBinary(b []byte) error {
	if len(b) != 6 {
		return errors.Errorf("invalid binary size %d: %x", len(b), b)
	}
	for i, bb := range b[2:] {
		m.streamID |= uint32(bb) << (8 * uint(3-i))
	}
	return nil
}

func UnmarshalStreamIsRecordedBinary(b []byte) (StreamIsRecorded, error) {
	m := streamIsRecorded{}
	err := m.UnmarshalBinary(b)
	return &m, err
}

func ReadStreamIsRecorded(r io.Reader) (StreamIsRecorded, error) {
	b := make([]byte, 6)
	if _, err := io.ReadFull(r, b); err != nil {
		return nil, errors.Wrap(err, "failed to read bytes")
	}
	return UnmarshalStreamIsRecordedBinary(b)
}

func (m streamIsRecorded) MarshalLogObject(enc zapcore.ObjectEncoder) error {
	enc.AddString("eventType", m.EventType().String())
	enc.AddUint32("streamID", m.StreamID())
	return nil
}

type PingRequest interface {
	UserControlMessage
	encoding.BinaryUnmarshaler
	Timestamp() uint32
}

type pingRequest struct {
	timestamp uint32
}

func NewPingRequest(
	timestamp uint32,
) PingRequest {
	return &pingRequest{
		timestamp: timestamp,
	}
}

func (m pingRequest) EventType() EventType {
	return EventTypePingRequest
}
func (m pingRequest) Timestamp() uint32 {
	return m.timestamp
}

func (m pingRequest) MarshalBinary() ([]byte, error) {
	b := make([]byte, 6)
	for i := range b[:2] {
		b[i] |= byte((EventTypePingRequest) >> (uint(1-i) * 8))
	}
	for i := range b[2:] {
		b[2+i] |= byte((m.timestamp) >> (uint(3-i) * 8))
	}
	return b, nil
}

func (m *pingRequest) UnmarshalBinary(b []byte) error {
	if len(b) != 6 {
		return errors.Errorf("invalid binary size %d: %x", len(b), b)
	}
	for i, bb := range b[2:] {
		m.timestamp |= uint32(bb) << (8 * uint(3-i))
	}
	return nil
}

func UnmarshalPingRequestBinary(b []byte) (PingRequest, error) {
	m := pingRequest{}
	err := m.UnmarshalBinary(b)
	return &m, err
}

func ReadPingRequest(r io.Reader) (PingRequest, error) {
	b := make([]byte, 6)
	if _, err := io.ReadFull(r, b); err != nil {
		return nil, errors.Wrap(err, "failed to read bytes")
	}
	return UnmarshalPingRequestBinary(b)
}

func (m pingRequest) MarshalLogObject(enc zapcore.ObjectEncoder) error {
	enc.AddString("eventType", m.EventType().String())
	enc.AddUint32("timestamp", m.Timestamp())
	return nil
}

type PingResponse interface {
	UserControlMessage
	encoding.BinaryUnmarshaler
	Timestamp() uint32
}

type pingResponse struct {
	timestamp uint32
}

func NewPingResponse(
	timestamp uint32,
) PingResponse {
	return &pingResponse{
		timestamp: timestamp,
	}
}

func (m pingResponse) EventType() EventType {
	return EventTypePingResponse
}
func (m pingResponse) Timestamp() uint32 {
	return m.timestamp
}

func (m pingResponse) MarshalBinary() ([]byte, error) {
	b := make([]byte, 6)
	for i := range b[:2] {
		b[i] |= byte((EventTypePingResponse) >> (uint(1-i) * 8))
	}
	for i := range b[2:] {
		b[2+i] |= byte((m.timestamp) >> (uint(3-i) * 8))
	}
	return b, nil
}

func (m *pingResponse) UnmarshalBinary(b []byte) error {
	if len(b) != 6 {
		return errors.Errorf("invalid binary size %d: %x", len(b), b)
	}
	for i, bb := range b[2:] {
		m.timestamp |= uint32(bb) << (8 * uint(3-i))
	}
	return nil
}

func UnmarshalPingResponseBinary(b []byte) (PingResponse, error) {
	m := pingResponse{}
	err := m.UnmarshalBinary(b)
	return &m, err
}

func ReadPingResponse(r io.Reader) (PingResponse, error) {
	b := make([]byte, 6)
	if _, err := io.ReadFull(r, b); err != nil {
		return nil, errors.Wrap(err, "failed to read bytes")
	}
	return UnmarshalPingResponseBinary(b)
}

func (m pingResponse) MarshalLogObject(enc zapcore.ObjectEncoder) error {
	enc.AddString("eventType", m.EventType().String())
	enc.AddUint32("timestamp", m.Timestamp())
	return nil
}
