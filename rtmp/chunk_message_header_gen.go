// Automatically generated by go generate; DO NOT EDIT.

package rtmp

import (
	"encoding"
	"io"

	"github.com/pkg/errors"
	"go.uber.org/zap/zapcore"
)

// There are four different formats for the chunk message header,
// selected by the "fmt" field in the chunk basic header.
//
// An implementation SHOULD use the most compact representation possible
// for each chunk message header.
type ChunkMessageHeader interface {
	encoding.BinaryMarshaler
	zapcore.ObjectMarshaler
	NeedsExtendedTimestamp() bool
}

type ChunkMessageHeaderType0 interface {
	ChunkMessageHeader
	encoding.BinaryUnmarshaler
	Timestamp() uint32
	MessageLength() uint32
	MessageTypeID() MessageTypeID
	MessageStreamID() uint32
}

type chunkMessageHeaderType0 struct {
	timestamp       uint32
	messageLength   uint32
	messageTypeID   MessageTypeID
	messageStreamID uint32
}

func NewChunkMessageHeaderType0(
	timestamp uint32,
	messageLength uint32,
	messageTypeID MessageTypeID,
	messageStreamID uint32,
) ChunkMessageHeaderType0 {
	return &chunkMessageHeaderType0{
		timestamp:       timestamp,
		messageLength:   messageLength,
		messageTypeID:   messageTypeID,
		messageStreamID: messageStreamID,
	}
}

func (m chunkMessageHeaderType0) Timestamp() uint32 {
	return m.timestamp
}
func (m chunkMessageHeaderType0) MessageLength() uint32 {
	return m.messageLength
}
func (m chunkMessageHeaderType0) MessageTypeID() MessageTypeID {
	return m.messageTypeID
}
func (m chunkMessageHeaderType0) MessageStreamID() uint32 {
	return m.messageStreamID
}

func (m chunkMessageHeaderType0) MarshalBinary() ([]byte, error) {
	b := make([]byte, 11)
	for i := range b[:3] {
		b[i] |= byte((m.timestamp) >> (uint(2-i) * 8))
	}
	for i := range b[3:6] {
		b[3+i] |= byte((m.messageLength) >> (uint(2-i) * 8))
	}
	b[6] |= byte(m.messageTypeID)
	for i := range b[7:] {
		b[7+i] |= byte((m.messageStreamID) >> (uint(i) * 8))
	}
	return b, nil
}

func (m *chunkMessageHeaderType0) UnmarshalBinary(b []byte) error {
	if len(b) != 11 {
		return errors.Errorf("invalid binary size %d: %x", len(b), b)
	}
	for i, bb := range b[:3] {
		m.timestamp |= uint32(bb) << (8 * uint(2-i))
	}
	for i, bb := range b[3:6] {
		m.messageLength |= uint32(bb) << (8 * uint(2-i))
	}
	m.messageTypeID = MessageTypeID(b[6])
	for i, bb := range b[7:] {
		m.messageStreamID |= uint32(bb) << (8 * uint(i))
	}
	return nil
}

func UnmarshalChunkMessageHeaderType0Binary(b []byte) (ChunkMessageHeaderType0, error) {
	m := chunkMessageHeaderType0{}
	err := m.UnmarshalBinary(b)
	return &m, err
}

func ReadChunkMessageHeaderType0(r io.Reader) (ChunkMessageHeaderType0, error) {
	b := make([]byte, 11)
	if _, err := io.ReadFull(r, b); err != nil {
		return nil, errors.Wrap(err, "failed to read bytes")
	}
	return UnmarshalChunkMessageHeaderType0Binary(b)
}

func (m chunkMessageHeaderType0) MarshalLogObject(enc zapcore.ObjectEncoder) error {
	enc.AddUint32("timestamp", m.Timestamp())
	enc.AddUint32("messageLength", m.MessageLength())
	enc.AddString("messageTypeID", m.MessageTypeID().String())
	enc.AddUint32("messageStreamID", m.MessageStreamID())
	return nil
}

type ChunkMessageHeaderType1 interface {
	ChunkMessageHeader
	encoding.BinaryUnmarshaler
	TimestampDelta() uint32
	MessageLength() uint32
	MessageTypeID() MessageTypeID
}

type chunkMessageHeaderType1 struct {
	timestampDelta uint32
	messageLength  uint32
	messageTypeID  MessageTypeID
}

func NewChunkMessageHeaderType1(
	timestampDelta uint32,
	messageLength uint32,
	messageTypeID MessageTypeID,
) ChunkMessageHeaderType1 {
	return &chunkMessageHeaderType1{
		timestampDelta: timestampDelta,
		messageLength:  messageLength,
		messageTypeID:  messageTypeID,
	}
}

func (m chunkMessageHeaderType1) TimestampDelta() uint32 {
	return m.timestampDelta
}
func (m chunkMessageHeaderType1) MessageLength() uint32 {
	return m.messageLength
}
func (m chunkMessageHeaderType1) MessageTypeID() MessageTypeID {
	return m.messageTypeID
}

func (m chunkMessageHeaderType1) MarshalBinary() ([]byte, error) {
	b := make([]byte, 7)
	for i := range b[:3] {
		b[i] |= byte((m.timestampDelta) >> (uint(2-i) * 8))
	}
	for i := range b[3:6] {
		b[3+i] |= byte((m.messageLength) >> (uint(2-i) * 8))
	}
	b[6] |= byte(m.messageTypeID)
	return b, nil
}

func (m *chunkMessageHeaderType1) UnmarshalBinary(b []byte) error {
	if len(b) != 7 {
		return errors.Errorf("invalid binary size %d: %x", len(b), b)
	}
	for i, bb := range b[:3] {
		m.timestampDelta |= uint32(bb) << (8 * uint(2-i))
	}
	for i, bb := range b[3:6] {
		m.messageLength |= uint32(bb) << (8 * uint(2-i))
	}
	m.messageTypeID = MessageTypeID(b[6])
	return nil
}

func UnmarshalChunkMessageHeaderType1Binary(b []byte) (ChunkMessageHeaderType1, error) {
	m := chunkMessageHeaderType1{}
	err := m.UnmarshalBinary(b)
	return &m, err
}

func ReadChunkMessageHeaderType1(r io.Reader) (ChunkMessageHeaderType1, error) {
	b := make([]byte, 7)
	if _, err := io.ReadFull(r, b); err != nil {
		return nil, errors.Wrap(err, "failed to read bytes")
	}
	return UnmarshalChunkMessageHeaderType1Binary(b)
}

func (m chunkMessageHeaderType1) MarshalLogObject(enc zapcore.ObjectEncoder) error {
	enc.AddUint32("timestampDelta", m.TimestampDelta())
	enc.AddUint32("messageLength", m.MessageLength())
	enc.AddString("messageTypeID", m.MessageTypeID().String())
	return nil
}

type ChunkMessageHeaderType2 interface {
	ChunkMessageHeader
	encoding.BinaryUnmarshaler
	TimestampDelta() uint32
}

type chunkMessageHeaderType2 struct {
	timestampDelta uint32
}

func NewChunkMessageHeaderType2(
	timestampDelta uint32,
) ChunkMessageHeaderType2 {
	return &chunkMessageHeaderType2{
		timestampDelta: timestampDelta,
	}
}

func (m chunkMessageHeaderType2) TimestampDelta() uint32 {
	return m.timestampDelta
}

func (m chunkMessageHeaderType2) MarshalBinary() ([]byte, error) {
	b := make([]byte, 3)
	for i := range b {
		b[i] |= byte((m.timestampDelta) >> (uint(2-i) * 8))
	}
	return b, nil
}

func (m *chunkMessageHeaderType2) UnmarshalBinary(b []byte) error {
	if len(b) != 3 {
		return errors.Errorf("invalid binary size %d: %x", len(b), b)
	}
	for i, bb := range b[:] {
		m.timestampDelta |= uint32(bb) << (8 * uint(2-i))
	}
	return nil
}

func UnmarshalChunkMessageHeaderType2Binary(b []byte) (ChunkMessageHeaderType2, error) {
	m := chunkMessageHeaderType2{}
	err := m.UnmarshalBinary(b)
	return &m, err
}

func ReadChunkMessageHeaderType2(r io.Reader) (ChunkMessageHeaderType2, error) {
	b := make([]byte, 3)
	if _, err := io.ReadFull(r, b); err != nil {
		return nil, errors.Wrap(err, "failed to read bytes")
	}
	return UnmarshalChunkMessageHeaderType2Binary(b)
}

func (m chunkMessageHeaderType2) MarshalLogObject(enc zapcore.ObjectEncoder) error {
	enc.AddUint32("timestampDelta", m.TimestampDelta())
	return nil
}

type ChunkMessageHeaderType3 interface {
	ChunkMessageHeader
	encoding.BinaryUnmarshaler
}

type chunkMessageHeaderType3 struct {
}

func NewChunkMessageHeaderType3() ChunkMessageHeaderType3 {
	return &chunkMessageHeaderType3{}
}

func (m chunkMessageHeaderType3) MarshalBinary() ([]byte, error) {
	b := make([]byte, 0)
	return b, nil
}

func (m *chunkMessageHeaderType3) UnmarshalBinary(b []byte) error {
	if len(b) != 0 {
		return errors.Errorf("invalid binary size %d: %x", len(b), b)
	}
	return nil
}

func UnmarshalChunkMessageHeaderType3Binary(b []byte) (ChunkMessageHeaderType3, error) {
	m := chunkMessageHeaderType3{}
	err := m.UnmarshalBinary(b)
	return &m, err
}

func ReadChunkMessageHeaderType3(r io.Reader) (ChunkMessageHeaderType3, error) {
	b := make([]byte, 0)
	if _, err := io.ReadFull(r, b); err != nil {
		return nil, errors.Wrap(err, "failed to read bytes")
	}
	return UnmarshalChunkMessageHeaderType3Binary(b)
}

func (m chunkMessageHeaderType3) MarshalLogObject(enc zapcore.ObjectEncoder) error {
	return nil
}
