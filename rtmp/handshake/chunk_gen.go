// Automatically generated by go generate; DO NOT EDIT.

package handshake

import (
	"encoding"
	"io"

	"github.com/pkg/errors"
	"go.uber.org/zap/zapcore"
)

type Chunk interface {
	encoding.BinaryMarshaler
	zapcore.ObjectMarshaler
}

type Chunk0 interface {
	Chunk
	encoding.BinaryUnmarshaler
	Version() uint8
}

type chunk0 struct {
	version uint8
}

func NewChunk0(
	version uint8,
) Chunk0 {
	return &chunk0{
		version: version,
	}
}

func (m chunk0) Version() uint8 {
	return m.version
}

func (m chunk0) MarshalBinary() ([]byte, error) {
	b := make([]byte, 1)
	b[0] |= m.version
	return b, nil
}

func (m *chunk0) UnmarshalBinary(b []byte) error {
	if len(b) != 1 {
		return errors.Errorf("invalid binary size %d: %x", len(b), b)
	}
	m.version = b[0]
	return nil
}

func UnmarshalChunk0Binary(b []byte) (Chunk0, error) {
	m := chunk0{}
	err := m.UnmarshalBinary(b)
	return &m, err
}

func ReadChunk0(r io.Reader) (Chunk0, error) {
	b := make([]byte, 1)
	if _, err := io.ReadFull(r, b); err != nil {
		return nil, errors.Wrap(err, "failed to read bytes")
	}
	return UnmarshalChunk0Binary(b)
}

func (m chunk0) MarshalLogObject(enc zapcore.ObjectEncoder) error {
	enc.AddUint8("version", m.Version())
	return nil
}

type Chunk1 interface {
	Chunk
	encoding.BinaryUnmarshaler
	Time() uint32
	RandomBytes() []byte
}

type chunk1 struct {
	time        uint32
	randomBytes []byte
}

func NewChunk1(
	time uint32,
	randomBytes []byte,
) Chunk1 {
	return &chunk1{
		time:        time,
		randomBytes: randomBytes,
	}
}

func (m chunk1) Time() uint32 {
	return m.time
}
func (m chunk1) RandomBytes() []byte {
	return m.randomBytes
}

func (m chunk1) MarshalBinary() ([]byte, error) {
	b := make([]byte, 1536)
	for i := range b[:4] {
		b[i] |= byte((m.time) >> (uint(3-i) * 8))
	}
	copy(b[8:], m.randomBytes)
	return b, nil
}

func (m *chunk1) UnmarshalBinary(b []byte) error {
	if len(b) != 1536 {
		return errors.Errorf("invalid binary size %d: %x", len(b), b)
	}
	for i, bb := range b[:4] {
		m.time |= uint32(bb) << (8 * uint(3-i))
	}
	m.randomBytes = b[8:]
	return nil
}

func UnmarshalChunk1Binary(b []byte) (Chunk1, error) {
	m := chunk1{}
	err := m.UnmarshalBinary(b)
	return &m, err
}

func ReadChunk1(r io.Reader) (Chunk1, error) {
	b := make([]byte, 1536)
	if _, err := io.ReadFull(r, b); err != nil {
		return nil, errors.Wrap(err, "failed to read bytes")
	}
	return UnmarshalChunk1Binary(b)
}

func (m chunk1) MarshalLogObject(enc zapcore.ObjectEncoder) error {
	enc.AddUint32("time", m.Time())
	enc.AddInt("randomBytesLength", len(m.RandomBytes()))
	return nil
}

type Chunk2 interface {
	Chunk
	encoding.BinaryUnmarshaler
	Time() uint32
	Time2() uint32
	RandomEcho() []byte
	Validate(chunk1 Chunk1) error
}

type chunk2 struct {
	time       uint32
	time2      uint32
	randomEcho []byte
}

func NewChunk2(
	time uint32,
	time2 uint32,
	randomEcho []byte,
) Chunk2 {
	return &chunk2{
		time:       time,
		time2:      time2,
		randomEcho: randomEcho,
	}
}

func (m chunk2) Time() uint32 {
	return m.time
}
func (m chunk2) Time2() uint32 {
	return m.time2
}
func (m chunk2) RandomEcho() []byte {
	return m.randomEcho
}

func (m chunk2) MarshalBinary() ([]byte, error) {
	b := make([]byte, 1536)
	for i := range b[:4] {
		b[i] |= byte((m.time) >> (uint(3-i) * 8))
	}
	for i := range b[4:8] {
		b[4+i] |= byte((m.time2) >> (uint(3-i) * 8))
	}
	copy(b[8:], m.randomEcho)
	return b, nil
}

func (m *chunk2) UnmarshalBinary(b []byte) error {
	if len(b) != 1536 {
		return errors.Errorf("invalid binary size %d: %x", len(b), b)
	}
	for i, bb := range b[:4] {
		m.time |= uint32(bb) << (8 * uint(3-i))
	}
	for i, bb := range b[4:8] {
		m.time2 |= uint32(bb) << (8 * uint(3-i))
	}
	m.randomEcho = b[8:]
	return nil
}

func UnmarshalChunk2Binary(b []byte) (Chunk2, error) {
	m := chunk2{}
	err := m.UnmarshalBinary(b)
	return &m, err
}

func ReadChunk2(r io.Reader) (Chunk2, error) {
	b := make([]byte, 1536)
	if _, err := io.ReadFull(r, b); err != nil {
		return nil, errors.Wrap(err, "failed to read bytes")
	}
	return UnmarshalChunk2Binary(b)
}

func (m chunk2) MarshalLogObject(enc zapcore.ObjectEncoder) error {
	enc.AddUint32("time", m.Time())
	enc.AddUint32("time2", m.Time2())
	enc.AddInt("randomEchoLength", len(m.RandomEcho()))
	return nil
}
