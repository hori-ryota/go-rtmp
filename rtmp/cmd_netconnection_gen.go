// Automatically generated by go generate; DO NOT EDIT.

package rtmp

import (
	"bytes"
	"encoding"
	"io"

	"github.com/pkg/errors"
	amf "github.com/zhangpeihao/goamf"
	"go.uber.org/zap/zapcore"
)

type AudioCodecFlag uint32

const (
	AudioCodecFlagNone    AudioCodecFlag = 1
	AudioCodecFlagAdpcm   AudioCodecFlag = 2
	AudioCodecFlagMp3     AudioCodecFlag = 4
	AudioCodecFlagIntel   AudioCodecFlag = 8
	AudioCodecFlagUnused  AudioCodecFlag = 16
	AudioCodecFlagNelly8  AudioCodecFlag = 32
	AudioCodecFlagNelly   AudioCodecFlag = 64
	AudioCodecFlagG711a   AudioCodecFlag = 128
	AudioCodecFlagG711u   AudioCodecFlag = 256
	AudioCodecFlagNelly16 AudioCodecFlag = 512
	AudioCodecFlagAac     AudioCodecFlag = 1024
	AudioCodecFlagSpeex   AudioCodecFlag = 2048
	AudioCodecFlagAll     AudioCodecFlag = 4095
)

type VideoCodecFlag uint32

const (
	VideoCodecFlagUnused    VideoCodecFlag = 1
	VideoCodecFlagJpeg      VideoCodecFlag = 2
	VideoCodecFlagSorenson  VideoCodecFlag = 4
	VideoCodecFlagHomebrew  VideoCodecFlag = 8
	VideoCodecFlagVp6       VideoCodecFlag = 16
	VideoCodecFlagVp6alpha  VideoCodecFlag = 32
	VideoCodecFlagHomebrewv VideoCodecFlag = 64
	VideoCodecFlagH264      VideoCodecFlag = 128
	VideoCodecFlagAll       VideoCodecFlag = 255
)

type VideoFunctionFlag uint8

const (
	VideoFunctionFlagClientSeek VideoFunctionFlag = 1
)

type EncodingAMFType uint8

const (
	EncodingAMFTypeAMF0 EncodingAMFType = 0
	EncodingAMFTypeAMF3 EncodingAMFType = 3
)

type ConnectResponse interface {
	encoding.BinaryMarshaler
	zapcore.ObjectMarshaler
	EncodingAMFType() EncodingAMFType
	SetEncodingAMFType(EncodingAMFType)
}

type CreateStreamResponse interface {
	encoding.BinaryMarshaler
	zapcore.ObjectMarshaler
	EncodingAMFType() EncodingAMFType
	SetEncodingAMFType(EncodingAMFType)
}

type Connect interface {
	encoding.BinaryMarshaler
	zapcore.ObjectMarshaler
	CommandName() string
	TransactionID() uint32
	CommandObject() map[string]interface{}
	OptionalUserArguments() map[string]interface{}
	EncodingAMFType() EncodingAMFType
	SetEncodingAMFType(EncodingAMFType)
}

type connect struct {
	commandObject         map[string]interface{}
	optionalUserArguments map[string]interface{}
	encodingAMFType       EncodingAMFType
}

func NewConnect(
	commandObject map[string]interface{},
	optionalUserArguments map[string]interface{},
	encodingAMFType EncodingAMFType,
) Connect {
	return &connect{
		commandObject:         commandObject,
		optionalUserArguments: optionalUserArguments,
		encodingAMFType:       encodingAMFType,
	}
}

func (m connect) CommandName() string {
	return "connect"
}
func (m connect) TransactionID() uint32 {
	return 1
}
func (m connect) CommandObject() map[string]interface{} {
	return m.commandObject
}
func (m connect) OptionalUserArguments() map[string]interface{} {
	return m.optionalUserArguments
}
func (m connect) EncodingAMFType() EncodingAMFType {
	return m.encodingAMFType
}

func (m *connect) SetEncodingAMFType(v EncodingAMFType) {
	m.encodingAMFType = v
}

func (m connect) MarshalBinary() ([]byte, error) {
	b := new(bytes.Buffer)
	var err error

	if m.EncodingAMFType() == EncodingAMFTypeAMF0 {
		_, err = amf.WriteString(b, m.CommandName())
		if err != nil {
			return nil, errors.Wrap(err, "failed to write commandName: type string")
		}
		_, err = amf.WriteDouble(b, float64(m.TransactionID()))
		if err != nil {
			return nil, errors.Wrap(err, "failed to write transactionID: type uint32")
		}
		if m.CommandObject() == nil {
			_, err = amf.WriteNull(b)
		} else {
			_, err = amf.WriteObject(b, m.CommandObject())
		}
		if err != nil {
			return nil, errors.Wrap(err, "failed to write commandObject: type map")
		}
		if len(m.OptionalUserArguments()) != 0 {
			_, err = amf.WriteObject(b, m.OptionalUserArguments())
			if err != nil {
				return nil, errors.Wrap(err, "failed to write optionalUserArguments: type map")
			}
		}
		return b.Bytes(), nil
	}

	_, err = amf.AMF3_WriteString(b, m.CommandName())
	if err != nil {
		return nil, errors.Wrap(err, "failed to write commandName: type string")
	}
	_, err = amf.AMF3_WriteDouble(b, float64(m.TransactionID()))
	if err != nil {
		return nil, errors.Wrap(err, "failed to write transactionID: type uint32")
	}
	if m.CommandObject() == nil {
		_, err = amf.AMF3_WriteNull(b)
	} else {
		_, err = amf.AMF3_WriteObject(b, m.CommandObject())
	}
	if err != nil {
		return nil, errors.Wrap(err, "failed to write commandObject: type map")
	}
	if len(m.OptionalUserArguments()) != 0 {
		_, err = amf.AMF3_WriteObject(b, m.OptionalUserArguments())
		if err != nil {
			return nil, errors.Wrap(err, "failed to write optionalUserArguments: type map")
		}
	}
	return b.Bytes(), nil
}

func (m *connect) UnmarshalBinary(b []byte) error {
	r := bytes.NewReader(b)
	var err error

	if m.EncodingAMFType() == EncodingAMFTypeAMF0 {
		_, err = amf.ReadString(r)
		if err != nil {
			return errors.Wrap(err, "failed to read commandName: type string")
		}
		_, err = amf.ReadDouble(r)
		if err != nil {
			return errors.Wrap(err, "failed to read transactionID: type uint32")
		}
		if f, err := amf.ReadMarker(r); err != nil {
			return errors.Wrap(err, "failed to read commandObject: type map")
		} else if f == amf.AMF0_OBJECT_MARKER {
			m.commandObject, err = amf.ReadObjectProperty(r)
			if err != nil {
				return errors.Wrap(err, "failed to read commandObject: type map")
			}
		}
		if f, err := amf.ReadMarker(r); err != nil {
			if errors.Cause(err) == io.EOF {
				return nil
			}
			return errors.Wrap(err, "failed to read optionalUserArguments: type map")
		} else if f == amf.AMF0_OBJECT_MARKER {
			m.optionalUserArguments, err = amf.ReadObjectProperty(r)
			if err != nil {
				return errors.Wrap(err, "failed to read optionalUserArguments: type map")
			}
		}
		return nil
	}

	_, err = amf.AMF3_ReadString(r)
	if err != nil {
		return errors.Wrap(err, "failed to read commandName: type string")
	}
	_, err = amf.AMF3_ReadDouble(r)
	if err != nil {
		return errors.Wrap(err, "failed to read transactionID: type uint32")
	}
	if f, err := amf.ReadMarker(r); err != nil {
		return errors.Wrap(err, "failed to read commandObject: type map")
	} else if f == amf.AMF3_OBJECT_MARKER {
		m.commandObject, err = amf.AMF3_ReadObjectProperty(r)
		if err != nil {
			return errors.Wrap(err, "failed to read commandObject: type map")
		}
	}
	if f, err := amf.ReadMarker(r); err != nil {
		if errors.Cause(err) == io.EOF {
			return nil
		}
		return errors.Wrap(err, "failed to read optionalUserArguments: type map")
	} else if f == amf.AMF3_OBJECT_MARKER {
		m.optionalUserArguments, err = amf.AMF3_ReadObjectProperty(r)
		if err != nil {
			return errors.Wrap(err, "failed to read optionalUserArguments: type map")
		}
	}
	return nil
}
func UnmarshalConnectBinary(b []byte, encodingAMFType EncodingAMFType) (Connect, error) {
	m := connect{}
	m.SetEncodingAMFType(encodingAMFType)
	err := m.UnmarshalBinary(b)
	return &m, err
}
func (m connect) MarshalLogObject(enc zapcore.ObjectEncoder) error {
	enc.AddString("commandName", m.CommandName())
	enc.AddUint32("transactionID", m.TransactionID())
	if err := enc.AddReflected("commandObject", m.CommandObject()); err != nil {
		return errors.Wrap(err, "failed to AddReflect commandObject")
	}
	if err := enc.AddReflected("optionalUserArguments", m.OptionalUserArguments()); err != nil {
		return errors.Wrap(err, "failed to AddReflect optionalUserArguments")
	}
	enc.AddString("encodingAMFType", m.EncodingAMFType().String())
	return nil
}

type ConnectResult interface {
	ConnectResponse
	CommandName() string
	TransactionID() uint32
	Properties() map[string]interface{}
	Information() map[string]interface{}
}

type connectResult struct {
	properties      map[string]interface{}
	information     map[string]interface{}
	encodingAMFType EncodingAMFType
}

func NewConnectResult(
	properties map[string]interface{},
	information map[string]interface{},
	encodingAMFType EncodingAMFType,
) ConnectResult {
	return &connectResult{
		properties:      properties,
		information:     information,
		encodingAMFType: encodingAMFType,
	}
}

func (m connectResult) CommandName() string {
	return "_result"
}
func (m connectResult) TransactionID() uint32 {
	return 1
}
func (m connectResult) Properties() map[string]interface{} {
	return m.properties
}
func (m connectResult) Information() map[string]interface{} {
	return m.information
}
func (m connectResult) EncodingAMFType() EncodingAMFType {
	return m.encodingAMFType
}

func (m *connectResult) SetEncodingAMFType(v EncodingAMFType) {
	m.encodingAMFType = v
}

func (m connectResult) MarshalBinary() ([]byte, error) {
	b := new(bytes.Buffer)
	var err error

	if m.EncodingAMFType() == EncodingAMFTypeAMF0 {
		_, err = amf.WriteString(b, m.CommandName())
		if err != nil {
			return nil, errors.Wrap(err, "failed to write commandName: type string")
		}
		_, err = amf.WriteDouble(b, float64(m.TransactionID()))
		if err != nil {
			return nil, errors.Wrap(err, "failed to write transactionID: type uint32")
		}
		if m.Properties() == nil {
			_, err = amf.WriteNull(b)
		} else {
			_, err = amf.WriteObject(b, m.Properties())
		}
		if err != nil {
			return nil, errors.Wrap(err, "failed to write properties: type map")
		}
		if m.Information() == nil {
			_, err = amf.WriteNull(b)
		} else {
			_, err = amf.WriteObject(b, m.Information())
		}
		if err != nil {
			return nil, errors.Wrap(err, "failed to write information: type map")
		}
		return b.Bytes(), nil
	}

	_, err = amf.AMF3_WriteString(b, m.CommandName())
	if err != nil {
		return nil, errors.Wrap(err, "failed to write commandName: type string")
	}
	_, err = amf.AMF3_WriteDouble(b, float64(m.TransactionID()))
	if err != nil {
		return nil, errors.Wrap(err, "failed to write transactionID: type uint32")
	}
	if m.Properties() == nil {
		_, err = amf.AMF3_WriteNull(b)
	} else {
		_, err = amf.AMF3_WriteObject(b, m.Properties())
	}
	if err != nil {
		return nil, errors.Wrap(err, "failed to write properties: type map")
	}
	if m.Information() == nil {
		_, err = amf.AMF3_WriteNull(b)
	} else {
		_, err = amf.AMF3_WriteObject(b, m.Information())
	}
	if err != nil {
		return nil, errors.Wrap(err, "failed to write information: type map")
	}
	return b.Bytes(), nil
}

func (m *connectResult) UnmarshalBinary(b []byte) error {
	r := bytes.NewReader(b)
	var err error

	if m.EncodingAMFType() == EncodingAMFTypeAMF0 {
		_, err = amf.ReadString(r)
		if err != nil {
			return errors.Wrap(err, "failed to read commandName: type string")
		}
		_, err = amf.ReadDouble(r)
		if err != nil {
			return errors.Wrap(err, "failed to read transactionID: type uint32")
		}
		if f, err := amf.ReadMarker(r); err != nil {
			return errors.Wrap(err, "failed to read properties: type map")
		} else if f == amf.AMF0_OBJECT_MARKER {
			m.properties, err = amf.ReadObjectProperty(r)
			if err != nil {
				return errors.Wrap(err, "failed to read properties: type map")
			}
		}
		if f, err := amf.ReadMarker(r); err != nil {
			return errors.Wrap(err, "failed to read information: type map")
		} else if f == amf.AMF0_OBJECT_MARKER {
			m.information, err = amf.ReadObjectProperty(r)
			if err != nil {
				return errors.Wrap(err, "failed to read information: type map")
			}
		}
		return nil
	}

	_, err = amf.AMF3_ReadString(r)
	if err != nil {
		return errors.Wrap(err, "failed to read commandName: type string")
	}
	_, err = amf.AMF3_ReadDouble(r)
	if err != nil {
		return errors.Wrap(err, "failed to read transactionID: type uint32")
	}
	if f, err := amf.ReadMarker(r); err != nil {
		return errors.Wrap(err, "failed to read properties: type map")
	} else if f == amf.AMF3_OBJECT_MARKER {
		m.properties, err = amf.AMF3_ReadObjectProperty(r)
		if err != nil {
			return errors.Wrap(err, "failed to read properties: type map")
		}
	}
	if f, err := amf.ReadMarker(r); err != nil {
		return errors.Wrap(err, "failed to read information: type map")
	} else if f == amf.AMF3_OBJECT_MARKER {
		m.information, err = amf.AMF3_ReadObjectProperty(r)
		if err != nil {
			return errors.Wrap(err, "failed to read information: type map")
		}
	}
	return nil
}
func UnmarshalConnectResultBinary(b []byte, encodingAMFType EncodingAMFType) (ConnectResult, error) {
	m := connectResult{}
	m.SetEncodingAMFType(encodingAMFType)
	err := m.UnmarshalBinary(b)
	return &m, err
}
func (m connectResult) MarshalLogObject(enc zapcore.ObjectEncoder) error {
	enc.AddString("commandName", m.CommandName())
	enc.AddUint32("transactionID", m.TransactionID())
	if err := enc.AddReflected("properties", m.Properties()); err != nil {
		return errors.Wrap(err, "failed to AddReflect properties")
	}
	if err := enc.AddReflected("information", m.Information()); err != nil {
		return errors.Wrap(err, "failed to AddReflect information")
	}
	enc.AddString("encodingAMFType", m.EncodingAMFType().String())
	return nil
}

type ConnectError interface {
	ConnectResponse
	CommandName() string
	TransactionID() uint32
	Properties() map[string]interface{}
	Information() map[string]interface{}
}

type connectError struct {
	properties      map[string]interface{}
	information     map[string]interface{}
	encodingAMFType EncodingAMFType
}

func NewConnectError(
	properties map[string]interface{},
	information map[string]interface{},
	encodingAMFType EncodingAMFType,
) ConnectError {
	return &connectError{
		properties:      properties,
		information:     information,
		encodingAMFType: encodingAMFType,
	}
}

func (m connectError) CommandName() string {
	return "_error"
}
func (m connectError) TransactionID() uint32 {
	return 1
}
func (m connectError) Properties() map[string]interface{} {
	return m.properties
}
func (m connectError) Information() map[string]interface{} {
	return m.information
}
func (m connectError) EncodingAMFType() EncodingAMFType {
	return m.encodingAMFType
}

func (m *connectError) SetEncodingAMFType(v EncodingAMFType) {
	m.encodingAMFType = v
}

func (m connectError) MarshalBinary() ([]byte, error) {
	b := new(bytes.Buffer)
	var err error

	if m.EncodingAMFType() == EncodingAMFTypeAMF0 {
		_, err = amf.WriteString(b, m.CommandName())
		if err != nil {
			return nil, errors.Wrap(err, "failed to write commandName: type string")
		}
		_, err = amf.WriteDouble(b, float64(m.TransactionID()))
		if err != nil {
			return nil, errors.Wrap(err, "failed to write transactionID: type uint32")
		}
		if m.Properties() == nil {
			_, err = amf.WriteNull(b)
		} else {
			_, err = amf.WriteObject(b, m.Properties())
		}
		if err != nil {
			return nil, errors.Wrap(err, "failed to write properties: type map")
		}
		if m.Information() == nil {
			_, err = amf.WriteNull(b)
		} else {
			_, err = amf.WriteObject(b, m.Information())
		}
		if err != nil {
			return nil, errors.Wrap(err, "failed to write information: type map")
		}
		return b.Bytes(), nil
	}

	_, err = amf.AMF3_WriteString(b, m.CommandName())
	if err != nil {
		return nil, errors.Wrap(err, "failed to write commandName: type string")
	}
	_, err = amf.AMF3_WriteDouble(b, float64(m.TransactionID()))
	if err != nil {
		return nil, errors.Wrap(err, "failed to write transactionID: type uint32")
	}
	if m.Properties() == nil {
		_, err = amf.AMF3_WriteNull(b)
	} else {
		_, err = amf.AMF3_WriteObject(b, m.Properties())
	}
	if err != nil {
		return nil, errors.Wrap(err, "failed to write properties: type map")
	}
	if m.Information() == nil {
		_, err = amf.AMF3_WriteNull(b)
	} else {
		_, err = amf.AMF3_WriteObject(b, m.Information())
	}
	if err != nil {
		return nil, errors.Wrap(err, "failed to write information: type map")
	}
	return b.Bytes(), nil
}

func (m *connectError) UnmarshalBinary(b []byte) error {
	r := bytes.NewReader(b)
	var err error

	if m.EncodingAMFType() == EncodingAMFTypeAMF0 {
		_, err = amf.ReadString(r)
		if err != nil {
			return errors.Wrap(err, "failed to read commandName: type string")
		}
		_, err = amf.ReadDouble(r)
		if err != nil {
			return errors.Wrap(err, "failed to read transactionID: type uint32")
		}
		if f, err := amf.ReadMarker(r); err != nil {
			return errors.Wrap(err, "failed to read properties: type map")
		} else if f == amf.AMF0_OBJECT_MARKER {
			m.properties, err = amf.ReadObjectProperty(r)
			if err != nil {
				return errors.Wrap(err, "failed to read properties: type map")
			}
		}
		if f, err := amf.ReadMarker(r); err != nil {
			return errors.Wrap(err, "failed to read information: type map")
		} else if f == amf.AMF0_OBJECT_MARKER {
			m.information, err = amf.ReadObjectProperty(r)
			if err != nil {
				return errors.Wrap(err, "failed to read information: type map")
			}
		}
		return nil
	}

	_, err = amf.AMF3_ReadString(r)
	if err != nil {
		return errors.Wrap(err, "failed to read commandName: type string")
	}
	_, err = amf.AMF3_ReadDouble(r)
	if err != nil {
		return errors.Wrap(err, "failed to read transactionID: type uint32")
	}
	if f, err := amf.ReadMarker(r); err != nil {
		return errors.Wrap(err, "failed to read properties: type map")
	} else if f == amf.AMF3_OBJECT_MARKER {
		m.properties, err = amf.AMF3_ReadObjectProperty(r)
		if err != nil {
			return errors.Wrap(err, "failed to read properties: type map")
		}
	}
	if f, err := amf.ReadMarker(r); err != nil {
		return errors.Wrap(err, "failed to read information: type map")
	} else if f == amf.AMF3_OBJECT_MARKER {
		m.information, err = amf.AMF3_ReadObjectProperty(r)
		if err != nil {
			return errors.Wrap(err, "failed to read information: type map")
		}
	}
	return nil
}
func UnmarshalConnectErrorBinary(b []byte, encodingAMFType EncodingAMFType) (ConnectError, error) {
	m := connectError{}
	m.SetEncodingAMFType(encodingAMFType)
	err := m.UnmarshalBinary(b)
	return &m, err
}
func (m connectError) MarshalLogObject(enc zapcore.ObjectEncoder) error {
	enc.AddString("commandName", m.CommandName())
	enc.AddUint32("transactionID", m.TransactionID())
	if err := enc.AddReflected("properties", m.Properties()); err != nil {
		return errors.Wrap(err, "failed to AddReflect properties")
	}
	if err := enc.AddReflected("information", m.Information()); err != nil {
		return errors.Wrap(err, "failed to AddReflect information")
	}
	enc.AddString("encodingAMFType", m.EncodingAMFType().String())
	return nil
}

type Call interface {
	encoding.BinaryMarshaler
	zapcore.ObjectMarshaler
	ProcedureName() string
	TransactionID() uint32
	CommandObject() map[string]interface{}
	OptionalArguments() map[string]interface{}
	EncodingAMFType() EncodingAMFType
	SetEncodingAMFType(EncodingAMFType)
}

type call struct {
	procedureName     string
	transactionID     uint32
	commandObject     map[string]interface{}
	optionalArguments map[string]interface{}
	encodingAMFType   EncodingAMFType
}

func NewCall(
	procedureName string,
	transactionID uint32,
	commandObject map[string]interface{},
	optionalArguments map[string]interface{},
	encodingAMFType EncodingAMFType,
) Call {
	return &call{
		procedureName:     procedureName,
		transactionID:     transactionID,
		commandObject:     commandObject,
		optionalArguments: optionalArguments,
		encodingAMFType:   encodingAMFType,
	}
}

func (m call) ProcedureName() string {
	return m.procedureName
}
func (m call) TransactionID() uint32 {
	return m.transactionID
}
func (m call) CommandObject() map[string]interface{} {
	return m.commandObject
}
func (m call) OptionalArguments() map[string]interface{} {
	return m.optionalArguments
}
func (m call) EncodingAMFType() EncodingAMFType {
	return m.encodingAMFType
}

func (m *call) SetEncodingAMFType(v EncodingAMFType) {
	m.encodingAMFType = v
}

func (m call) MarshalBinary() ([]byte, error) {
	b := new(bytes.Buffer)
	var err error

	if m.EncodingAMFType() == EncodingAMFTypeAMF0 {
		_, err = amf.WriteString(b, m.ProcedureName())
		if err != nil {
			return nil, errors.Wrap(err, "failed to write procedureName: type string")
		}
		_, err = amf.WriteDouble(b, float64(m.TransactionID()))
		if err != nil {
			return nil, errors.Wrap(err, "failed to write transactionID: type uint32")
		}
		if m.CommandObject() == nil {
			_, err = amf.WriteNull(b)
		} else {
			_, err = amf.WriteObject(b, m.CommandObject())
		}
		if err != nil {
			return nil, errors.Wrap(err, "failed to write commandObject: type map")
		}
		if len(m.OptionalArguments()) != 0 {
			_, err = amf.WriteObject(b, m.OptionalArguments())
			if err != nil {
				return nil, errors.Wrap(err, "failed to write optionalArguments: type map")
			}
		}
		return b.Bytes(), nil
	}

	_, err = amf.AMF3_WriteString(b, m.ProcedureName())
	if err != nil {
		return nil, errors.Wrap(err, "failed to write procedureName: type string")
	}
	_, err = amf.AMF3_WriteDouble(b, float64(m.TransactionID()))
	if err != nil {
		return nil, errors.Wrap(err, "failed to write transactionID: type uint32")
	}
	if m.CommandObject() == nil {
		_, err = amf.AMF3_WriteNull(b)
	} else {
		_, err = amf.AMF3_WriteObject(b, m.CommandObject())
	}
	if err != nil {
		return nil, errors.Wrap(err, "failed to write commandObject: type map")
	}
	if len(m.OptionalArguments()) != 0 {
		_, err = amf.AMF3_WriteObject(b, m.OptionalArguments())
		if err != nil {
			return nil, errors.Wrap(err, "failed to write optionalArguments: type map")
		}
	}
	return b.Bytes(), nil
}

func (m *call) UnmarshalBinary(b []byte) error {
	r := bytes.NewReader(b)
	var err error

	if m.EncodingAMFType() == EncodingAMFTypeAMF0 {
		m.procedureName, err = amf.ReadString(r)
		if err != nil {
			return errors.Wrap(err, "failed to read procedureName: type string")
		}
		if f, err := amf.ReadDouble(r); err != nil {
			return errors.Wrap(err, "failed to read transactionID: type uint32")
		} else {
			m.transactionID = uint32(f)
		}
		if f, err := amf.ReadMarker(r); err != nil {
			return errors.Wrap(err, "failed to read commandObject: type map")
		} else if f == amf.AMF0_OBJECT_MARKER {
			m.commandObject, err = amf.ReadObjectProperty(r)
			if err != nil {
				return errors.Wrap(err, "failed to read commandObject: type map")
			}
		}
		if f, err := amf.ReadMarker(r); err != nil {
			if errors.Cause(err) == io.EOF {
				return nil
			}
			return errors.Wrap(err, "failed to read optionalArguments: type map")
		} else if f == amf.AMF0_OBJECT_MARKER {
			m.optionalArguments, err = amf.ReadObjectProperty(r)
			if err != nil {
				return errors.Wrap(err, "failed to read optionalArguments: type map")
			}
		}
		return nil
	}

	m.procedureName, err = amf.AMF3_ReadString(r)
	if err != nil {
		return errors.Wrap(err, "failed to read procedureName: type string")
	}
	if f, err := amf.AMF3_ReadDouble(r); err != nil {
		return errors.Wrap(err, "failed to read transactionID: type uint32")
	} else {
		m.transactionID = uint32(f)
	}
	if f, err := amf.ReadMarker(r); err != nil {
		return errors.Wrap(err, "failed to read commandObject: type map")
	} else if f == amf.AMF3_OBJECT_MARKER {
		m.commandObject, err = amf.AMF3_ReadObjectProperty(r)
		if err != nil {
			return errors.Wrap(err, "failed to read commandObject: type map")
		}
	}
	if f, err := amf.ReadMarker(r); err != nil {
		if errors.Cause(err) == io.EOF {
			return nil
		}
		return errors.Wrap(err, "failed to read optionalArguments: type map")
	} else if f == amf.AMF3_OBJECT_MARKER {
		m.optionalArguments, err = amf.AMF3_ReadObjectProperty(r)
		if err != nil {
			return errors.Wrap(err, "failed to read optionalArguments: type map")
		}
	}
	return nil
}
func UnmarshalCallBinary(b []byte, encodingAMFType EncodingAMFType) (Call, error) {
	m := call{}
	m.SetEncodingAMFType(encodingAMFType)
	err := m.UnmarshalBinary(b)
	return &m, err
}
func (m call) MarshalLogObject(enc zapcore.ObjectEncoder) error {
	enc.AddString("procedureName", m.ProcedureName())
	enc.AddUint32("transactionID", m.TransactionID())
	if err := enc.AddReflected("commandObject", m.CommandObject()); err != nil {
		return errors.Wrap(err, "failed to AddReflect commandObject")
	}
	if err := enc.AddReflected("optionalArguments", m.OptionalArguments()); err != nil {
		return errors.Wrap(err, "failed to AddReflect optionalArguments")
	}
	enc.AddString("encodingAMFType", m.EncodingAMFType().String())
	return nil
}

type CallResponse interface {
	encoding.BinaryMarshaler
	zapcore.ObjectMarshaler
	CommandName() string
	TransactionID() uint32
	CommandObject() map[string]interface{}
	Response() map[string]interface{}
	EncodingAMFType() EncodingAMFType
	SetEncodingAMFType(EncodingAMFType)
}

type callResponse struct {
	commandName     string
	transactionID   uint32
	commandObject   map[string]interface{}
	response        map[string]interface{}
	encodingAMFType EncodingAMFType
}

func NewCallResponse(
	commandName string,
	transactionID uint32,
	commandObject map[string]interface{},
	response map[string]interface{},
	encodingAMFType EncodingAMFType,
) CallResponse {
	return &callResponse{
		commandName:     commandName,
		transactionID:   transactionID,
		commandObject:   commandObject,
		response:        response,
		encodingAMFType: encodingAMFType,
	}
}

func (m callResponse) CommandName() string {
	return m.commandName
}
func (m callResponse) TransactionID() uint32 {
	return m.transactionID
}
func (m callResponse) CommandObject() map[string]interface{} {
	return m.commandObject
}
func (m callResponse) Response() map[string]interface{} {
	return m.response
}
func (m callResponse) EncodingAMFType() EncodingAMFType {
	return m.encodingAMFType
}

func (m *callResponse) SetEncodingAMFType(v EncodingAMFType) {
	m.encodingAMFType = v
}

func (m callResponse) MarshalBinary() ([]byte, error) {
	b := new(bytes.Buffer)
	var err error

	if m.EncodingAMFType() == EncodingAMFTypeAMF0 {
		_, err = amf.WriteString(b, m.CommandName())
		if err != nil {
			return nil, errors.Wrap(err, "failed to write commandName: type string")
		}
		_, err = amf.WriteDouble(b, float64(m.TransactionID()))
		if err != nil {
			return nil, errors.Wrap(err, "failed to write transactionID: type uint32")
		}
		if m.CommandObject() == nil {
			_, err = amf.WriteNull(b)
		} else {
			_, err = amf.WriteObject(b, m.CommandObject())
		}
		if err != nil {
			return nil, errors.Wrap(err, "failed to write commandObject: type map")
		}
		if m.Response() == nil {
			_, err = amf.WriteNull(b)
		} else {
			_, err = amf.WriteObject(b, m.Response())
		}
		if err != nil {
			return nil, errors.Wrap(err, "failed to write response: type map")
		}
		return b.Bytes(), nil
	}

	_, err = amf.AMF3_WriteString(b, m.CommandName())
	if err != nil {
		return nil, errors.Wrap(err, "failed to write commandName: type string")
	}
	_, err = amf.AMF3_WriteDouble(b, float64(m.TransactionID()))
	if err != nil {
		return nil, errors.Wrap(err, "failed to write transactionID: type uint32")
	}
	if m.CommandObject() == nil {
		_, err = amf.AMF3_WriteNull(b)
	} else {
		_, err = amf.AMF3_WriteObject(b, m.CommandObject())
	}
	if err != nil {
		return nil, errors.Wrap(err, "failed to write commandObject: type map")
	}
	if m.Response() == nil {
		_, err = amf.AMF3_WriteNull(b)
	} else {
		_, err = amf.AMF3_WriteObject(b, m.Response())
	}
	if err != nil {
		return nil, errors.Wrap(err, "failed to write response: type map")
	}
	return b.Bytes(), nil
}

func (m *callResponse) UnmarshalBinary(b []byte) error {
	r := bytes.NewReader(b)
	var err error

	if m.EncodingAMFType() == EncodingAMFTypeAMF0 {
		m.commandName, err = amf.ReadString(r)
		if err != nil {
			return errors.Wrap(err, "failed to read commandName: type string")
		}
		if f, err := amf.ReadDouble(r); err != nil {
			return errors.Wrap(err, "failed to read transactionID: type uint32")
		} else {
			m.transactionID = uint32(f)
		}
		if f, err := amf.ReadMarker(r); err != nil {
			return errors.Wrap(err, "failed to read commandObject: type map")
		} else if f == amf.AMF0_OBJECT_MARKER {
			m.commandObject, err = amf.ReadObjectProperty(r)
			if err != nil {
				return errors.Wrap(err, "failed to read commandObject: type map")
			}
		}
		if f, err := amf.ReadMarker(r); err != nil {
			return errors.Wrap(err, "failed to read response: type map")
		} else if f == amf.AMF0_OBJECT_MARKER {
			m.response, err = amf.ReadObjectProperty(r)
			if err != nil {
				return errors.Wrap(err, "failed to read response: type map")
			}
		}
		return nil
	}

	m.commandName, err = amf.AMF3_ReadString(r)
	if err != nil {
		return errors.Wrap(err, "failed to read commandName: type string")
	}
	if f, err := amf.AMF3_ReadDouble(r); err != nil {
		return errors.Wrap(err, "failed to read transactionID: type uint32")
	} else {
		m.transactionID = uint32(f)
	}
	if f, err := amf.ReadMarker(r); err != nil {
		return errors.Wrap(err, "failed to read commandObject: type map")
	} else if f == amf.AMF3_OBJECT_MARKER {
		m.commandObject, err = amf.AMF3_ReadObjectProperty(r)
		if err != nil {
			return errors.Wrap(err, "failed to read commandObject: type map")
		}
	}
	if f, err := amf.ReadMarker(r); err != nil {
		return errors.Wrap(err, "failed to read response: type map")
	} else if f == amf.AMF3_OBJECT_MARKER {
		m.response, err = amf.AMF3_ReadObjectProperty(r)
		if err != nil {
			return errors.Wrap(err, "failed to read response: type map")
		}
	}
	return nil
}
func UnmarshalCallResponseBinary(b []byte, encodingAMFType EncodingAMFType) (CallResponse, error) {
	m := callResponse{}
	m.SetEncodingAMFType(encodingAMFType)
	err := m.UnmarshalBinary(b)
	return &m, err
}
func (m callResponse) MarshalLogObject(enc zapcore.ObjectEncoder) error {
	enc.AddString("commandName", m.CommandName())
	enc.AddUint32("transactionID", m.TransactionID())
	if err := enc.AddReflected("commandObject", m.CommandObject()); err != nil {
		return errors.Wrap(err, "failed to AddReflect commandObject")
	}
	if err := enc.AddReflected("response", m.Response()); err != nil {
		return errors.Wrap(err, "failed to AddReflect response")
	}
	enc.AddString("encodingAMFType", m.EncodingAMFType().String())
	return nil
}

type Close interface {
	encoding.BinaryMarshaler
	zapcore.ObjectMarshaler
	CommandName() string
	EncodingAMFType() EncodingAMFType
	SetEncodingAMFType(EncodingAMFType)
}

type close struct {
	encodingAMFType EncodingAMFType
}

func NewClose(
	encodingAMFType EncodingAMFType,
) Close {
	return &close{
		encodingAMFType: encodingAMFType,
	}
}

func (m close) CommandName() string {
	return "close"
}
func (m close) EncodingAMFType() EncodingAMFType {
	return m.encodingAMFType
}

func (m *close) SetEncodingAMFType(v EncodingAMFType) {
	m.encodingAMFType = v
}

func (m close) MarshalBinary() ([]byte, error) {
	b := new(bytes.Buffer)
	var err error

	if m.EncodingAMFType() == EncodingAMFTypeAMF0 {
		_, err = amf.WriteString(b, m.CommandName())
		if err != nil {
			return nil, errors.Wrap(err, "failed to write commandName: type string")
		}
		return b.Bytes(), nil
	}

	_, err = amf.AMF3_WriteString(b, m.CommandName())
	if err != nil {
		return nil, errors.Wrap(err, "failed to write commandName: type string")
	}
	return b.Bytes(), nil
}

func (m *close) UnmarshalBinary(b []byte) error {
	r := bytes.NewReader(b)
	var err error

	if m.EncodingAMFType() == EncodingAMFTypeAMF0 {
		_, err = amf.ReadString(r)
		if err != nil {
			return errors.Wrap(err, "failed to read commandName: type string")
		}
		return nil
	}

	_, err = amf.AMF3_ReadString(r)
	if err != nil {
		return errors.Wrap(err, "failed to read commandName: type string")
	}
	return nil
}
func UnmarshalCloseBinary(b []byte, encodingAMFType EncodingAMFType) (Close, error) {
	m := close{}
	m.SetEncodingAMFType(encodingAMFType)
	err := m.UnmarshalBinary(b)
	return &m, err
}
func (m close) MarshalLogObject(enc zapcore.ObjectEncoder) error {
	enc.AddString("commandName", m.CommandName())
	enc.AddString("encodingAMFType", m.EncodingAMFType().String())
	return nil
}

type CreateStream interface {
	encoding.BinaryMarshaler
	zapcore.ObjectMarshaler
	CommandName() string
	TransactionID() uint32
	CommandObject() map[string]interface{}
	EncodingAMFType() EncodingAMFType
	SetEncodingAMFType(EncodingAMFType)
}

type createStream struct {
	transactionID   uint32
	commandObject   map[string]interface{}
	encodingAMFType EncodingAMFType
}

func NewCreateStream(
	transactionID uint32,
	commandObject map[string]interface{},
	encodingAMFType EncodingAMFType,
) CreateStream {
	return &createStream{
		transactionID:   transactionID,
		commandObject:   commandObject,
		encodingAMFType: encodingAMFType,
	}
}

func (m createStream) CommandName() string {
	return "createStream"
}
func (m createStream) TransactionID() uint32 {
	return m.transactionID
}
func (m createStream) CommandObject() map[string]interface{} {
	return m.commandObject
}
func (m createStream) EncodingAMFType() EncodingAMFType {
	return m.encodingAMFType
}

func (m *createStream) SetEncodingAMFType(v EncodingAMFType) {
	m.encodingAMFType = v
}

func (m createStream) MarshalBinary() ([]byte, error) {
	b := new(bytes.Buffer)
	var err error

	if m.EncodingAMFType() == EncodingAMFTypeAMF0 {
		_, err = amf.WriteString(b, m.CommandName())
		if err != nil {
			return nil, errors.Wrap(err, "failed to write commandName: type string")
		}
		_, err = amf.WriteDouble(b, float64(m.TransactionID()))
		if err != nil {
			return nil, errors.Wrap(err, "failed to write transactionID: type uint32")
		}
		if m.CommandObject() == nil {
			_, err = amf.WriteNull(b)
		} else {
			_, err = amf.WriteObject(b, m.CommandObject())
		}
		if err != nil {
			return nil, errors.Wrap(err, "failed to write commandObject: type map")
		}
		return b.Bytes(), nil
	}

	_, err = amf.AMF3_WriteString(b, m.CommandName())
	if err != nil {
		return nil, errors.Wrap(err, "failed to write commandName: type string")
	}
	_, err = amf.AMF3_WriteDouble(b, float64(m.TransactionID()))
	if err != nil {
		return nil, errors.Wrap(err, "failed to write transactionID: type uint32")
	}
	if m.CommandObject() == nil {
		_, err = amf.AMF3_WriteNull(b)
	} else {
		_, err = amf.AMF3_WriteObject(b, m.CommandObject())
	}
	if err != nil {
		return nil, errors.Wrap(err, "failed to write commandObject: type map")
	}
	return b.Bytes(), nil
}

func (m *createStream) UnmarshalBinary(b []byte) error {
	r := bytes.NewReader(b)
	var err error

	if m.EncodingAMFType() == EncodingAMFTypeAMF0 {
		_, err = amf.ReadString(r)
		if err != nil {
			return errors.Wrap(err, "failed to read commandName: type string")
		}
		if f, err := amf.ReadDouble(r); err != nil {
			return errors.Wrap(err, "failed to read transactionID: type uint32")
		} else {
			m.transactionID = uint32(f)
		}
		if f, err := amf.ReadMarker(r); err != nil {
			return errors.Wrap(err, "failed to read commandObject: type map")
		} else if f == amf.AMF0_OBJECT_MARKER {
			m.commandObject, err = amf.ReadObjectProperty(r)
			if err != nil {
				return errors.Wrap(err, "failed to read commandObject: type map")
			}
		}
		return nil
	}

	_, err = amf.AMF3_ReadString(r)
	if err != nil {
		return errors.Wrap(err, "failed to read commandName: type string")
	}
	if f, err := amf.AMF3_ReadDouble(r); err != nil {
		return errors.Wrap(err, "failed to read transactionID: type uint32")
	} else {
		m.transactionID = uint32(f)
	}
	if f, err := amf.ReadMarker(r); err != nil {
		return errors.Wrap(err, "failed to read commandObject: type map")
	} else if f == amf.AMF3_OBJECT_MARKER {
		m.commandObject, err = amf.AMF3_ReadObjectProperty(r)
		if err != nil {
			return errors.Wrap(err, "failed to read commandObject: type map")
		}
	}
	return nil
}
func UnmarshalCreateStreamBinary(b []byte, encodingAMFType EncodingAMFType) (CreateStream, error) {
	m := createStream{}
	m.SetEncodingAMFType(encodingAMFType)
	err := m.UnmarshalBinary(b)
	return &m, err
}
func (m createStream) MarshalLogObject(enc zapcore.ObjectEncoder) error {
	enc.AddString("commandName", m.CommandName())
	enc.AddUint32("transactionID", m.TransactionID())
	if err := enc.AddReflected("commandObject", m.CommandObject()); err != nil {
		return errors.Wrap(err, "failed to AddReflect commandObject")
	}
	enc.AddString("encodingAMFType", m.EncodingAMFType().String())
	return nil
}

type CreateStreamResult interface {
	CreateStreamResponse
	CommandName() string
	TransactionID() uint32
	CommandObject() map[string]interface{}
	StreamID() uint32
}

type createStreamResult struct {
	transactionID   uint32
	commandObject   map[string]interface{}
	streamID        uint32
	encodingAMFType EncodingAMFType
}

func NewCreateStreamResult(
	transactionID uint32,
	commandObject map[string]interface{},
	streamID uint32,
	encodingAMFType EncodingAMFType,
) CreateStreamResult {
	return &createStreamResult{
		transactionID:   transactionID,
		commandObject:   commandObject,
		streamID:        streamID,
		encodingAMFType: encodingAMFType,
	}
}

func (m createStreamResult) CommandName() string {
	return "_result"
}
func (m createStreamResult) TransactionID() uint32 {
	return m.transactionID
}
func (m createStreamResult) CommandObject() map[string]interface{} {
	return m.commandObject
}
func (m createStreamResult) StreamID() uint32 {
	return m.streamID
}
func (m createStreamResult) EncodingAMFType() EncodingAMFType {
	return m.encodingAMFType
}

func (m *createStreamResult) SetEncodingAMFType(v EncodingAMFType) {
	m.encodingAMFType = v
}

func (m createStreamResult) MarshalBinary() ([]byte, error) {
	b := new(bytes.Buffer)
	var err error

	if m.EncodingAMFType() == EncodingAMFTypeAMF0 {
		_, err = amf.WriteString(b, m.CommandName())
		if err != nil {
			return nil, errors.Wrap(err, "failed to write commandName: type string")
		}
		_, err = amf.WriteDouble(b, float64(m.TransactionID()))
		if err != nil {
			return nil, errors.Wrap(err, "failed to write transactionID: type uint32")
		}
		if m.CommandObject() == nil {
			_, err = amf.WriteNull(b)
		} else {
			_, err = amf.WriteObject(b, m.CommandObject())
		}
		if err != nil {
			return nil, errors.Wrap(err, "failed to write commandObject: type map")
		}
		_, err = amf.WriteDouble(b, float64(m.StreamID()))
		if err != nil {
			return nil, errors.Wrap(err, "failed to write streamID: type uint32")
		}
		return b.Bytes(), nil
	}

	_, err = amf.AMF3_WriteString(b, m.CommandName())
	if err != nil {
		return nil, errors.Wrap(err, "failed to write commandName: type string")
	}
	_, err = amf.AMF3_WriteDouble(b, float64(m.TransactionID()))
	if err != nil {
		return nil, errors.Wrap(err, "failed to write transactionID: type uint32")
	}
	if m.CommandObject() == nil {
		_, err = amf.AMF3_WriteNull(b)
	} else {
		_, err = amf.AMF3_WriteObject(b, m.CommandObject())
	}
	if err != nil {
		return nil, errors.Wrap(err, "failed to write commandObject: type map")
	}
	_, err = amf.AMF3_WriteDouble(b, float64(m.StreamID()))
	if err != nil {
		return nil, errors.Wrap(err, "failed to write streamID: type uint32")
	}
	return b.Bytes(), nil
}

func (m *createStreamResult) UnmarshalBinary(b []byte) error {
	r := bytes.NewReader(b)
	var err error

	if m.EncodingAMFType() == EncodingAMFTypeAMF0 {
		_, err = amf.ReadString(r)
		if err != nil {
			return errors.Wrap(err, "failed to read commandName: type string")
		}
		if f, err := amf.ReadDouble(r); err != nil {
			return errors.Wrap(err, "failed to read transactionID: type uint32")
		} else {
			m.transactionID = uint32(f)
		}
		if f, err := amf.ReadMarker(r); err != nil {
			return errors.Wrap(err, "failed to read commandObject: type map")
		} else if f == amf.AMF0_OBJECT_MARKER {
			m.commandObject, err = amf.ReadObjectProperty(r)
			if err != nil {
				return errors.Wrap(err, "failed to read commandObject: type map")
			}
		}
		if f, err := amf.ReadDouble(r); err != nil {
			return errors.Wrap(err, "failed to read streamID: type uint32")
		} else {
			m.streamID = uint32(f)
		}
		return nil
	}

	_, err = amf.AMF3_ReadString(r)
	if err != nil {
		return errors.Wrap(err, "failed to read commandName: type string")
	}
	if f, err := amf.AMF3_ReadDouble(r); err != nil {
		return errors.Wrap(err, "failed to read transactionID: type uint32")
	} else {
		m.transactionID = uint32(f)
	}
	if f, err := amf.ReadMarker(r); err != nil {
		return errors.Wrap(err, "failed to read commandObject: type map")
	} else if f == amf.AMF3_OBJECT_MARKER {
		m.commandObject, err = amf.AMF3_ReadObjectProperty(r)
		if err != nil {
			return errors.Wrap(err, "failed to read commandObject: type map")
		}
	}
	if f, err := amf.AMF3_ReadDouble(r); err != nil {
		return errors.Wrap(err, "failed to read streamID: type uint32")
	} else {
		m.streamID = uint32(f)
	}
	return nil
}
func UnmarshalCreateStreamResultBinary(b []byte, encodingAMFType EncodingAMFType) (CreateStreamResult, error) {
	m := createStreamResult{}
	m.SetEncodingAMFType(encodingAMFType)
	err := m.UnmarshalBinary(b)
	return &m, err
}
func (m createStreamResult) MarshalLogObject(enc zapcore.ObjectEncoder) error {
	enc.AddString("commandName", m.CommandName())
	enc.AddUint32("transactionID", m.TransactionID())
	if err := enc.AddReflected("commandObject", m.CommandObject()); err != nil {
		return errors.Wrap(err, "failed to AddReflect commandObject")
	}
	enc.AddUint32("streamID", m.StreamID())
	enc.AddString("encodingAMFType", m.EncodingAMFType().String())
	return nil
}

type CreateStreamError interface {
	CreateStreamResponse
	CommandName() string
	TransactionID() uint32
	CommandObject() map[string]interface{}
	StreamID() uint32
}

type createStreamError struct {
	transactionID   uint32
	commandObject   map[string]interface{}
	streamID        uint32
	encodingAMFType EncodingAMFType
}

func NewCreateStreamError(
	transactionID uint32,
	commandObject map[string]interface{},
	streamID uint32,
	encodingAMFType EncodingAMFType,
) CreateStreamError {
	return &createStreamError{
		transactionID:   transactionID,
		commandObject:   commandObject,
		streamID:        streamID,
		encodingAMFType: encodingAMFType,
	}
}

func (m createStreamError) CommandName() string {
	return "_error"
}
func (m createStreamError) TransactionID() uint32 {
	return m.transactionID
}
func (m createStreamError) CommandObject() map[string]interface{} {
	return m.commandObject
}
func (m createStreamError) StreamID() uint32 {
	return m.streamID
}
func (m createStreamError) EncodingAMFType() EncodingAMFType {
	return m.encodingAMFType
}

func (m *createStreamError) SetEncodingAMFType(v EncodingAMFType) {
	m.encodingAMFType = v
}

func (m createStreamError) MarshalBinary() ([]byte, error) {
	b := new(bytes.Buffer)
	var err error

	if m.EncodingAMFType() == EncodingAMFTypeAMF0 {
		_, err = amf.WriteString(b, m.CommandName())
		if err != nil {
			return nil, errors.Wrap(err, "failed to write commandName: type string")
		}
		_, err = amf.WriteDouble(b, float64(m.TransactionID()))
		if err != nil {
			return nil, errors.Wrap(err, "failed to write transactionID: type uint32")
		}
		if m.CommandObject() == nil {
			_, err = amf.WriteNull(b)
		} else {
			_, err = amf.WriteObject(b, m.CommandObject())
		}
		if err != nil {
			return nil, errors.Wrap(err, "failed to write commandObject: type map")
		}
		_, err = amf.WriteDouble(b, float64(m.StreamID()))
		if err != nil {
			return nil, errors.Wrap(err, "failed to write streamID: type uint32")
		}
		return b.Bytes(), nil
	}

	_, err = amf.AMF3_WriteString(b, m.CommandName())
	if err != nil {
		return nil, errors.Wrap(err, "failed to write commandName: type string")
	}
	_, err = amf.AMF3_WriteDouble(b, float64(m.TransactionID()))
	if err != nil {
		return nil, errors.Wrap(err, "failed to write transactionID: type uint32")
	}
	if m.CommandObject() == nil {
		_, err = amf.AMF3_WriteNull(b)
	} else {
		_, err = amf.AMF3_WriteObject(b, m.CommandObject())
	}
	if err != nil {
		return nil, errors.Wrap(err, "failed to write commandObject: type map")
	}
	_, err = amf.AMF3_WriteDouble(b, float64(m.StreamID()))
	if err != nil {
		return nil, errors.Wrap(err, "failed to write streamID: type uint32")
	}
	return b.Bytes(), nil
}

func (m *createStreamError) UnmarshalBinary(b []byte) error {
	r := bytes.NewReader(b)
	var err error

	if m.EncodingAMFType() == EncodingAMFTypeAMF0 {
		_, err = amf.ReadString(r)
		if err != nil {
			return errors.Wrap(err, "failed to read commandName: type string")
		}
		if f, err := amf.ReadDouble(r); err != nil {
			return errors.Wrap(err, "failed to read transactionID: type uint32")
		} else {
			m.transactionID = uint32(f)
		}
		if f, err := amf.ReadMarker(r); err != nil {
			return errors.Wrap(err, "failed to read commandObject: type map")
		} else if f == amf.AMF0_OBJECT_MARKER {
			m.commandObject, err = amf.ReadObjectProperty(r)
			if err != nil {
				return errors.Wrap(err, "failed to read commandObject: type map")
			}
		}
		if f, err := amf.ReadDouble(r); err != nil {
			return errors.Wrap(err, "failed to read streamID: type uint32")
		} else {
			m.streamID = uint32(f)
		}
		return nil
	}

	_, err = amf.AMF3_ReadString(r)
	if err != nil {
		return errors.Wrap(err, "failed to read commandName: type string")
	}
	if f, err := amf.AMF3_ReadDouble(r); err != nil {
		return errors.Wrap(err, "failed to read transactionID: type uint32")
	} else {
		m.transactionID = uint32(f)
	}
	if f, err := amf.ReadMarker(r); err != nil {
		return errors.Wrap(err, "failed to read commandObject: type map")
	} else if f == amf.AMF3_OBJECT_MARKER {
		m.commandObject, err = amf.AMF3_ReadObjectProperty(r)
		if err != nil {
			return errors.Wrap(err, "failed to read commandObject: type map")
		}
	}
	if f, err := amf.AMF3_ReadDouble(r); err != nil {
		return errors.Wrap(err, "failed to read streamID: type uint32")
	} else {
		m.streamID = uint32(f)
	}
	return nil
}
func UnmarshalCreateStreamErrorBinary(b []byte, encodingAMFType EncodingAMFType) (CreateStreamError, error) {
	m := createStreamError{}
	m.SetEncodingAMFType(encodingAMFType)
	err := m.UnmarshalBinary(b)
	return &m, err
}
func (m createStreamError) MarshalLogObject(enc zapcore.ObjectEncoder) error {
	enc.AddString("commandName", m.CommandName())
	enc.AddUint32("transactionID", m.TransactionID())
	if err := enc.AddReflected("commandObject", m.CommandObject()); err != nil {
		return errors.Wrap(err, "failed to AddReflect commandObject")
	}
	enc.AddUint32("streamID", m.StreamID())
	enc.AddString("encodingAMFType", m.EncodingAMFType().String())
	return nil
}
