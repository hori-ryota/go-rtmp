// Automatically generated by go generate; DO NOT EDIT.

package rtmp

import (
	"encoding"
	"io"

	"github.com/pkg/errors"
	"go.uber.org/zap/zapcore"
)

type BandwidthLimitType uint8

const (
	BandwidthLimitTypeHard    BandwidthLimitType = 0
	BandwidthLimitTypeSoft    BandwidthLimitType = 1
	BandwidthLimitTypeDynamic BandwidthLimitType = 2
)

type SetChunkSize interface {
	encoding.BinaryMarshaler
	encoding.BinaryUnmarshaler
	zapcore.ObjectMarshaler
	ChunkSize() uint32
}

type setChunkSize struct {
	chunkSize uint32
}

func NewSetChunkSize(
	chunkSize uint32,
) SetChunkSize {
	return &setChunkSize{
		chunkSize: chunkSize,
	}
}

func (m setChunkSize) ChunkSize() uint32 {
	return m.chunkSize
}

func (m setChunkSize) MarshalBinary() ([]byte, error) {
	b := make([]byte, 4)
	for i := range b {
		b[i] |= byte((m.chunkSize) >> (uint(3-i) * 8))
	}
	return b, nil
}

func (m *setChunkSize) UnmarshalBinary(b []byte) error {
	if len(b) != 4 {
		return errors.Errorf("invalid binary size %d: %x", len(b), b)
	}
	for i, bb := range b[:] {
		m.chunkSize |= uint32(bb) << (8 * uint(3-i))
	}
	return nil
}

func UnmarshalSetChunkSizeBinary(b []byte) (SetChunkSize, error) {
	m := setChunkSize{}
	err := m.UnmarshalBinary(b)
	return &m, err
}

func ReadSetChunkSize(r io.Reader) (SetChunkSize, error) {
	b := make([]byte, 4)
	if _, err := io.ReadFull(r, b); err != nil {
		return nil, errors.Wrap(err, "failed to read bytes")
	}
	return UnmarshalSetChunkSizeBinary(b)
}

func (m setChunkSize) MarshalLogObject(enc zapcore.ObjectEncoder) error {
	enc.AddUint32("chunkSize", m.ChunkSize())
	return nil
}

type AbortMessage interface {
	encoding.BinaryMarshaler
	encoding.BinaryUnmarshaler
	zapcore.ObjectMarshaler
	ChunkStreamID() uint32
}

type abortMessage struct {
	chunkStreamID uint32
}

func NewAbortMessage(
	chunkStreamID uint32,
) AbortMessage {
	return &abortMessage{
		chunkStreamID: chunkStreamID,
	}
}

func (m abortMessage) ChunkStreamID() uint32 {
	return m.chunkStreamID
}

func (m abortMessage) MarshalBinary() ([]byte, error) {
	b := make([]byte, 4)
	for i := range b {
		b[i] |= byte((m.chunkStreamID) >> (uint(3-i) * 8))
	}
	return b, nil
}

func (m *abortMessage) UnmarshalBinary(b []byte) error {
	if len(b) != 4 {
		return errors.Errorf("invalid binary size %d: %x", len(b), b)
	}
	for i, bb := range b[:] {
		m.chunkStreamID |= uint32(bb) << (8 * uint(3-i))
	}
	return nil
}

func UnmarshalAbortMessageBinary(b []byte) (AbortMessage, error) {
	m := abortMessage{}
	err := m.UnmarshalBinary(b)
	return &m, err
}

func ReadAbortMessage(r io.Reader) (AbortMessage, error) {
	b := make([]byte, 4)
	if _, err := io.ReadFull(r, b); err != nil {
		return nil, errors.Wrap(err, "failed to read bytes")
	}
	return UnmarshalAbortMessageBinary(b)
}

func (m abortMessage) MarshalLogObject(enc zapcore.ObjectEncoder) error {
	enc.AddUint32("chunkStreamID", m.ChunkStreamID())
	return nil
}

type Acknowledgement interface {
	encoding.BinaryMarshaler
	encoding.BinaryUnmarshaler
	zapcore.ObjectMarshaler
	SequenceNumber() uint32
}

type acknowledgement struct {
	sequenceNumber uint32
}

func NewAcknowledgement(
	sequenceNumber uint32,
) Acknowledgement {
	return &acknowledgement{
		sequenceNumber: sequenceNumber,
	}
}

func (m acknowledgement) SequenceNumber() uint32 {
	return m.sequenceNumber
}

func (m acknowledgement) MarshalBinary() ([]byte, error) {
	b := make([]byte, 4)
	for i := range b {
		b[i] |= byte((m.sequenceNumber) >> (uint(3-i) * 8))
	}
	return b, nil
}

func (m *acknowledgement) UnmarshalBinary(b []byte) error {
	if len(b) != 4 {
		return errors.Errorf("invalid binary size %d: %x", len(b), b)
	}
	for i, bb := range b[:] {
		m.sequenceNumber |= uint32(bb) << (8 * uint(3-i))
	}
	return nil
}

func UnmarshalAcknowledgementBinary(b []byte) (Acknowledgement, error) {
	m := acknowledgement{}
	err := m.UnmarshalBinary(b)
	return &m, err
}

func ReadAcknowledgement(r io.Reader) (Acknowledgement, error) {
	b := make([]byte, 4)
	if _, err := io.ReadFull(r, b); err != nil {
		return nil, errors.Wrap(err, "failed to read bytes")
	}
	return UnmarshalAcknowledgementBinary(b)
}

func (m acknowledgement) MarshalLogObject(enc zapcore.ObjectEncoder) error {
	enc.AddUint32("sequenceNumber", m.SequenceNumber())
	return nil
}

type WindowAcknowledgementSize interface {
	encoding.BinaryMarshaler
	encoding.BinaryUnmarshaler
	zapcore.ObjectMarshaler
	AcknowledgementWindowSize() uint32
}

type windowAcknowledgementSize struct {
	acknowledgementWindowSize uint32
}

func NewWindowAcknowledgementSize(
	acknowledgementWindowSize uint32,
) WindowAcknowledgementSize {
	return &windowAcknowledgementSize{
		acknowledgementWindowSize: acknowledgementWindowSize,
	}
}

func (m windowAcknowledgementSize) AcknowledgementWindowSize() uint32 {
	return m.acknowledgementWindowSize
}

func (m windowAcknowledgementSize) MarshalBinary() ([]byte, error) {
	b := make([]byte, 4)
	for i := range b {
		b[i] |= byte((m.acknowledgementWindowSize) >> (uint(3-i) * 8))
	}
	return b, nil
}

func (m *windowAcknowledgementSize) UnmarshalBinary(b []byte) error {
	if len(b) != 4 {
		return errors.Errorf("invalid binary size %d: %x", len(b), b)
	}
	for i, bb := range b[:] {
		m.acknowledgementWindowSize |= uint32(bb) << (8 * uint(3-i))
	}
	return nil
}

func UnmarshalWindowAcknowledgementSizeBinary(b []byte) (WindowAcknowledgementSize, error) {
	m := windowAcknowledgementSize{}
	err := m.UnmarshalBinary(b)
	return &m, err
}

func ReadWindowAcknowledgementSize(r io.Reader) (WindowAcknowledgementSize, error) {
	b := make([]byte, 4)
	if _, err := io.ReadFull(r, b); err != nil {
		return nil, errors.Wrap(err, "failed to read bytes")
	}
	return UnmarshalWindowAcknowledgementSizeBinary(b)
}

func (m windowAcknowledgementSize) MarshalLogObject(enc zapcore.ObjectEncoder) error {
	enc.AddUint32("acknowledgementWindowSize", m.AcknowledgementWindowSize())
	return nil
}

type SetPeerBandwidth interface {
	encoding.BinaryMarshaler
	encoding.BinaryUnmarshaler
	zapcore.ObjectMarshaler
	AcknowledgmentWindowSize() uint32
	LimitType() BandwidthLimitType
}

type setPeerBandwidth struct {
	acknowledgmentWindowSize uint32
	limitType                BandwidthLimitType
}

func NewSetPeerBandwidth(
	acknowledgmentWindowSize uint32,
	limitType BandwidthLimitType,
) SetPeerBandwidth {
	return &setPeerBandwidth{
		acknowledgmentWindowSize: acknowledgmentWindowSize,
		limitType:                limitType,
	}
}

func (m setPeerBandwidth) AcknowledgmentWindowSize() uint32 {
	return m.acknowledgmentWindowSize
}
func (m setPeerBandwidth) LimitType() BandwidthLimitType {
	return m.limitType
}

func (m setPeerBandwidth) MarshalBinary() ([]byte, error) {
	b := make([]byte, 5)
	for i := range b[:4] {
		b[i] |= byte((m.acknowledgmentWindowSize) >> (uint(3-i) * 8))
	}
	b[4] |= byte(m.limitType)
	return b, nil
}

func (m *setPeerBandwidth) UnmarshalBinary(b []byte) error {
	if len(b) != 5 {
		return errors.Errorf("invalid binary size %d: %x", len(b), b)
	}
	for i, bb := range b[:4] {
		m.acknowledgmentWindowSize |= uint32(bb) << (8 * uint(3-i))
	}
	m.limitType = BandwidthLimitType(b[4])
	return nil
}

func UnmarshalSetPeerBandwidthBinary(b []byte) (SetPeerBandwidth, error) {
	m := setPeerBandwidth{}
	err := m.UnmarshalBinary(b)
	return &m, err
}

func ReadSetPeerBandwidth(r io.Reader) (SetPeerBandwidth, error) {
	b := make([]byte, 5)
	if _, err := io.ReadFull(r, b); err != nil {
		return nil, errors.Wrap(err, "failed to read bytes")
	}
	return UnmarshalSetPeerBandwidthBinary(b)
}

func (m setPeerBandwidth) MarshalLogObject(enc zapcore.ObjectEncoder) error {
	enc.AddUint32("acknowledgmentWindowSize", m.AcknowledgmentWindowSize())
	enc.AddString("limitType", m.LimitType().String())
	return nil
}
