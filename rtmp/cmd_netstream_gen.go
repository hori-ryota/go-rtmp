// Automatically generated by go generate; DO NOT EDIT.

package rtmp

import (
	"bytes"
	"encoding"

	"github.com/pkg/errors"
	amf "github.com/zhangpeihao/goamf"
	"go.uber.org/zap/zapcore"
)

type PublishingType string

const (
	PublishingTypeLive   PublishingType = "live"
	PublishingTypeRecord PublishingType = "record"
	PublishingTypeAppend PublishingType = "append"
)

type OnStatus interface {
	encoding.BinaryMarshaler
	zapcore.ObjectMarshaler
	CommandName() string
	TransactionID() uint32
	CommandObject() map[string]interface{}
	InfoObject() map[string]interface{}
	EncodingAMFType() EncodingAMFType
	SetEncodingAMFType(EncodingAMFType)
}

type onStatus struct {
	infoObject      map[string]interface{}
	encodingAMFType EncodingAMFType
}

func NewOnStatus(
	infoObject map[string]interface{},
	encodingAMFType EncodingAMFType,
) OnStatus {
	return &onStatus{
		infoObject:      infoObject,
		encodingAMFType: encodingAMFType,
	}
}

func (m onStatus) CommandName() string {
	return "onStatus"
}
func (m onStatus) TransactionID() uint32 {
	return 0
}
func (m onStatus) CommandObject() map[string]interface{} {
	return nil
}
func (m onStatus) InfoObject() map[string]interface{} {
	return m.infoObject
}
func (m onStatus) EncodingAMFType() EncodingAMFType {
	return m.encodingAMFType
}

func (m *onStatus) SetEncodingAMFType(v EncodingAMFType) {
	m.encodingAMFType = v
}

func (m onStatus) MarshalBinary() ([]byte, error) {
	b := new(bytes.Buffer)
	var err error

	if m.EncodingAMFType() == EncodingAMFTypeAMF0 {
		_, err = amf.WriteString(b, m.CommandName())
		if err != nil {
			return nil, errors.Wrap(err, "failed to write commandName: type string")
		}
		_, err = amf.WriteDouble(b, float64(m.TransactionID()))
		if err != nil {
			return nil, errors.Wrap(err, "failed to write transactionID: type uint32")
		}
		if m.CommandObject() == nil {
			_, err = amf.WriteNull(b)
		} else {
			_, err = amf.WriteObject(b, m.CommandObject())
		}
		if err != nil {
			return nil, errors.Wrap(err, "failed to write commandObject: type map")
		}
		if m.InfoObject() == nil {
			_, err = amf.WriteNull(b)
		} else {
			_, err = amf.WriteObject(b, m.InfoObject())
		}
		if err != nil {
			return nil, errors.Wrap(err, "failed to write infoObject: type map")
		}
		return b.Bytes(), nil
	}

	_, err = amf.AMF3_WriteString(b, m.CommandName())
	if err != nil {
		return nil, errors.Wrap(err, "failed to write commandName: type string")
	}
	_, err = amf.AMF3_WriteDouble(b, float64(m.TransactionID()))
	if err != nil {
		return nil, errors.Wrap(err, "failed to write transactionID: type uint32")
	}
	if m.CommandObject() == nil {
		_, err = amf.AMF3_WriteNull(b)
	} else {
		_, err = amf.AMF3_WriteObject(b, m.CommandObject())
	}
	if err != nil {
		return nil, errors.Wrap(err, "failed to write commandObject: type map")
	}
	if m.InfoObject() == nil {
		_, err = amf.AMF3_WriteNull(b)
	} else {
		_, err = amf.AMF3_WriteObject(b, m.InfoObject())
	}
	if err != nil {
		return nil, errors.Wrap(err, "failed to write infoObject: type map")
	}
	return b.Bytes(), nil
}

func (m *onStatus) UnmarshalBinary(b []byte) error {
	r := bytes.NewReader(b)
	var err error

	if m.EncodingAMFType() == EncodingAMFTypeAMF0 {
		_, err = amf.ReadString(r)
		if err != nil {
			return errors.Wrap(err, "failed to read commandName: type string")
		}
		_, err = amf.ReadDouble(r)
		if err != nil {
			return errors.Wrap(err, "failed to read transactionID: type uint32")
		}
		_, err = amf.ReadMarker(r)
		if err != nil {
			return errors.Wrap(err, "failed to read commandObject: type map")
		}
		if f, err := amf.ReadMarker(r); err != nil {
			return errors.Wrap(err, "failed to read infoObject: type map")
		} else if f == amf.AMF0_OBJECT_MARKER {
			m.infoObject, err = amf.ReadObjectProperty(r)
			if err != nil {
				return errors.Wrap(err, "failed to read infoObject: type map")
			}
		}
		return nil
	}

	_, err = amf.AMF3_ReadString(r)
	if err != nil {
		return errors.Wrap(err, "failed to read commandName: type string")
	}
	_, err = amf.AMF3_ReadDouble(r)
	if err != nil {
		return errors.Wrap(err, "failed to read transactionID: type uint32")
	}
	_, err = amf.ReadMarker(r)
	if err != nil {
		return errors.Wrap(err, "failed to read commandObject: type map")
	}
	if f, err := amf.ReadMarker(r); err != nil {
		return errors.Wrap(err, "failed to read infoObject: type map")
	} else if f == amf.AMF3_OBJECT_MARKER {
		m.infoObject, err = amf.AMF3_ReadObjectProperty(r)
		if err != nil {
			return errors.Wrap(err, "failed to read infoObject: type map")
		}
	}
	return nil
}
func UnmarshalOnStatusBinary(b []byte, encodingAMFType EncodingAMFType) (OnStatus, error) {
	m := onStatus{}
	m.SetEncodingAMFType(encodingAMFType)
	err := m.UnmarshalBinary(b)
	return &m, err
}
func (m onStatus) MarshalLogObject(enc zapcore.ObjectEncoder) error {
	enc.AddString("commandName", m.CommandName())
	enc.AddUint32("transactionID", m.TransactionID())
	if err := enc.AddReflected("commandObject", m.CommandObject()); err != nil {
		return errors.Wrap(err, "failed to AddReflect commandObject")
	}
	if err := enc.AddReflected("infoObject", m.InfoObject()); err != nil {
		return errors.Wrap(err, "failed to AddReflect infoObject")
	}
	enc.AddString("encodingAMFType", m.EncodingAMFType().String())
	return nil
}

type Play interface {
	encoding.BinaryMarshaler
	zapcore.ObjectMarshaler
	CommandName() string
	TransactionID() uint32
	CommandObject() map[string]interface{}
	StreamName() string
	Start() uint32
	Duration() uint32
	Reset() bool
	EncodingAMFType() EncodingAMFType
	SetEncodingAMFType(EncodingAMFType)
}

type play struct {
	streamName      string
	start           uint32
	duration        uint32
	reset           bool
	encodingAMFType EncodingAMFType
}

func NewPlay(
	streamName string,
	start uint32,
	duration uint32,
	reset bool,
	encodingAMFType EncodingAMFType,
) Play {
	return &play{
		streamName:      streamName,
		start:           start,
		duration:        duration,
		reset:           reset,
		encodingAMFType: encodingAMFType,
	}
}

func (m play) CommandName() string {
	return "play"
}
func (m play) TransactionID() uint32 {
	return 0
}
func (m play) CommandObject() map[string]interface{} {
	return nil
}
func (m play) StreamName() string {
	return m.streamName
}
func (m play) Start() uint32 {
	return m.start
}
func (m play) Duration() uint32 {
	return m.duration
}
func (m play) Reset() bool {
	return m.reset
}
func (m play) EncodingAMFType() EncodingAMFType {
	return m.encodingAMFType
}

func (m *play) SetEncodingAMFType(v EncodingAMFType) {
	m.encodingAMFType = v
}

func (m play) MarshalBinary() ([]byte, error) {
	b := new(bytes.Buffer)
	var err error

	if m.EncodingAMFType() == EncodingAMFTypeAMF0 {
		_, err = amf.WriteString(b, m.CommandName())
		if err != nil {
			return nil, errors.Wrap(err, "failed to write commandName: type string")
		}
		_, err = amf.WriteDouble(b, float64(m.TransactionID()))
		if err != nil {
			return nil, errors.Wrap(err, "failed to write transactionID: type uint32")
		}
		if m.CommandObject() == nil {
			_, err = amf.WriteNull(b)
		} else {
			_, err = amf.WriteObject(b, m.CommandObject())
		}
		if err != nil {
			return nil, errors.Wrap(err, "failed to write commandObject: type map")
		}
		_, err = amf.WriteString(b, m.StreamName())
		if err != nil {
			return nil, errors.Wrap(err, "failed to write streamName: type string")
		}
		_, err = amf.WriteDouble(b, float64(m.Start()))
		if err != nil {
			return nil, errors.Wrap(err, "failed to write start: type uint32")
		}
		_, err = amf.WriteDouble(b, float64(m.Duration()))
		if err != nil {
			return nil, errors.Wrap(err, "failed to write duration: type uint32")
		}
		_, err = amf.WriteBoolean(b, m.Reset())
		if err != nil {
			return nil, errors.Wrap(err, "failed to write reset: type bool")
		}
		return b.Bytes(), nil
	}

	_, err = amf.AMF3_WriteString(b, m.CommandName())
	if err != nil {
		return nil, errors.Wrap(err, "failed to write commandName: type string")
	}
	_, err = amf.AMF3_WriteDouble(b, float64(m.TransactionID()))
	if err != nil {
		return nil, errors.Wrap(err, "failed to write transactionID: type uint32")
	}
	if m.CommandObject() == nil {
		_, err = amf.AMF3_WriteNull(b)
	} else {
		_, err = amf.AMF3_WriteObject(b, m.CommandObject())
	}
	if err != nil {
		return nil, errors.Wrap(err, "failed to write commandObject: type map")
	}
	_, err = amf.AMF3_WriteString(b, m.StreamName())
	if err != nil {
		return nil, errors.Wrap(err, "failed to write streamName: type string")
	}
	_, err = amf.AMF3_WriteDouble(b, float64(m.Start()))
	if err != nil {
		return nil, errors.Wrap(err, "failed to write start: type uint32")
	}
	_, err = amf.AMF3_WriteDouble(b, float64(m.Duration()))
	if err != nil {
		return nil, errors.Wrap(err, "failed to write duration: type uint32")
	}
	_, err = amf.AMF3_WriteBoolean(b, m.Reset())
	if err != nil {
		return nil, errors.Wrap(err, "failed to write reset: type bool")
	}
	return b.Bytes(), nil
}

func (m *play) UnmarshalBinary(b []byte) error {
	r := bytes.NewReader(b)
	var err error

	if m.EncodingAMFType() == EncodingAMFTypeAMF0 {
		_, err = amf.ReadString(r)
		if err != nil {
			return errors.Wrap(err, "failed to read commandName: type string")
		}
		_, err = amf.ReadDouble(r)
		if err != nil {
			return errors.Wrap(err, "failed to read transactionID: type uint32")
		}
		_, err = amf.ReadMarker(r)
		if err != nil {
			return errors.Wrap(err, "failed to read commandObject: type map")
		}
		m.streamName, err = amf.ReadString(r)
		if err != nil {
			return errors.Wrap(err, "failed to read streamName: type string")
		}
		if f, err := amf.ReadDouble(r); err != nil {
			return errors.Wrap(err, "failed to read start: type uint32")
		} else {
			m.start = uint32(f)
		}
		if f, err := amf.ReadDouble(r); err != nil {
			return errors.Wrap(err, "failed to read duration: type uint32")
		} else {
			m.duration = uint32(f)
		}
		m.reset, err = amf.ReadBoolean(r)
		if err != nil {
			return errors.Wrap(err, "failed to read reset: type bool")
		}
		return nil
	}

	_, err = amf.AMF3_ReadString(r)
	if err != nil {
		return errors.Wrap(err, "failed to read commandName: type string")
	}
	_, err = amf.AMF3_ReadDouble(r)
	if err != nil {
		return errors.Wrap(err, "failed to read transactionID: type uint32")
	}
	_, err = amf.ReadMarker(r)
	if err != nil {
		return errors.Wrap(err, "failed to read commandObject: type map")
	}
	m.streamName, err = amf.AMF3_ReadString(r)
	if err != nil {
		return errors.Wrap(err, "failed to read streamName: type string")
	}
	if f, err := amf.AMF3_ReadDouble(r); err != nil {
		return errors.Wrap(err, "failed to read start: type uint32")
	} else {
		m.start = uint32(f)
	}
	if f, err := amf.AMF3_ReadDouble(r); err != nil {
		return errors.Wrap(err, "failed to read duration: type uint32")
	} else {
		m.duration = uint32(f)
	}
	if mk, err := amf.ReadMarker(r); err != nil {
		return errors.Wrap(err, "failed to read reset: type bool")
	} else {
		m.reset = mk == amf.AMF3_TRUE_MARKER
	}
	return nil
}
func UnmarshalPlayBinary(b []byte, encodingAMFType EncodingAMFType) (Play, error) {
	m := play{}
	m.SetEncodingAMFType(encodingAMFType)
	err := m.UnmarshalBinary(b)
	return &m, err
}
func (m play) MarshalLogObject(enc zapcore.ObjectEncoder) error {
	enc.AddString("commandName", m.CommandName())
	enc.AddUint32("transactionID", m.TransactionID())
	if err := enc.AddReflected("commandObject", m.CommandObject()); err != nil {
		return errors.Wrap(err, "failed to AddReflect commandObject")
	}
	enc.AddString("streamName", m.StreamName())
	enc.AddUint32("start", m.Start())
	enc.AddUint32("duration", m.Duration())
	enc.AddBool("reset", m.Reset())
	enc.AddString("encodingAMFType", m.EncodingAMFType().String())
	return nil
}

type Play2 interface {
	encoding.BinaryMarshaler
	zapcore.ObjectMarshaler
	CommandName() string
	TransactionID() uint32
	CommandObject() map[string]interface{}
	Parameters() map[string]interface{}
	EncodingAMFType() EncodingAMFType
	SetEncodingAMFType(EncodingAMFType)
}

type play2 struct {
	parameters      map[string]interface{}
	encodingAMFType EncodingAMFType
}

func NewPlay2(
	parameters map[string]interface{},
	encodingAMFType EncodingAMFType,
) Play2 {
	return &play2{
		parameters:      parameters,
		encodingAMFType: encodingAMFType,
	}
}

func (m play2) CommandName() string {
	return "play2"
}
func (m play2) TransactionID() uint32 {
	return 0
}
func (m play2) CommandObject() map[string]interface{} {
	return nil
}
func (m play2) Parameters() map[string]interface{} {
	return m.parameters
}
func (m play2) EncodingAMFType() EncodingAMFType {
	return m.encodingAMFType
}

func (m *play2) SetEncodingAMFType(v EncodingAMFType) {
	m.encodingAMFType = v
}

func (m play2) MarshalBinary() ([]byte, error) {
	b := new(bytes.Buffer)
	var err error

	if m.EncodingAMFType() == EncodingAMFTypeAMF0 {
		_, err = amf.WriteString(b, m.CommandName())
		if err != nil {
			return nil, errors.Wrap(err, "failed to write commandName: type string")
		}
		_, err = amf.WriteDouble(b, float64(m.TransactionID()))
		if err != nil {
			return nil, errors.Wrap(err, "failed to write transactionID: type uint32")
		}
		if m.CommandObject() == nil {
			_, err = amf.WriteNull(b)
		} else {
			_, err = amf.WriteObject(b, m.CommandObject())
		}
		if err != nil {
			return nil, errors.Wrap(err, "failed to write commandObject: type map")
		}
		if m.Parameters() == nil {
			_, err = amf.WriteNull(b)
		} else {
			_, err = amf.WriteObject(b, m.Parameters())
		}
		if err != nil {
			return nil, errors.Wrap(err, "failed to write parameters: type map")
		}
		return b.Bytes(), nil
	}

	_, err = amf.AMF3_WriteString(b, m.CommandName())
	if err != nil {
		return nil, errors.Wrap(err, "failed to write commandName: type string")
	}
	_, err = amf.AMF3_WriteDouble(b, float64(m.TransactionID()))
	if err != nil {
		return nil, errors.Wrap(err, "failed to write transactionID: type uint32")
	}
	if m.CommandObject() == nil {
		_, err = amf.AMF3_WriteNull(b)
	} else {
		_, err = amf.AMF3_WriteObject(b, m.CommandObject())
	}
	if err != nil {
		return nil, errors.Wrap(err, "failed to write commandObject: type map")
	}
	if m.Parameters() == nil {
		_, err = amf.AMF3_WriteNull(b)
	} else {
		_, err = amf.AMF3_WriteObject(b, m.Parameters())
	}
	if err != nil {
		return nil, errors.Wrap(err, "failed to write parameters: type map")
	}
	return b.Bytes(), nil
}

func (m *play2) UnmarshalBinary(b []byte) error {
	r := bytes.NewReader(b)
	var err error

	if m.EncodingAMFType() == EncodingAMFTypeAMF0 {
		_, err = amf.ReadString(r)
		if err != nil {
			return errors.Wrap(err, "failed to read commandName: type string")
		}
		_, err = amf.ReadDouble(r)
		if err != nil {
			return errors.Wrap(err, "failed to read transactionID: type uint32")
		}
		_, err = amf.ReadMarker(r)
		if err != nil {
			return errors.Wrap(err, "failed to read commandObject: type map")
		}
		if f, err := amf.ReadMarker(r); err != nil {
			return errors.Wrap(err, "failed to read parameters: type map")
		} else if f == amf.AMF0_OBJECT_MARKER {
			m.parameters, err = amf.ReadObjectProperty(r)
			if err != nil {
				return errors.Wrap(err, "failed to read parameters: type map")
			}
		}
		return nil
	}

	_, err = amf.AMF3_ReadString(r)
	if err != nil {
		return errors.Wrap(err, "failed to read commandName: type string")
	}
	_, err = amf.AMF3_ReadDouble(r)
	if err != nil {
		return errors.Wrap(err, "failed to read transactionID: type uint32")
	}
	_, err = amf.ReadMarker(r)
	if err != nil {
		return errors.Wrap(err, "failed to read commandObject: type map")
	}
	if f, err := amf.ReadMarker(r); err != nil {
		return errors.Wrap(err, "failed to read parameters: type map")
	} else if f == amf.AMF3_OBJECT_MARKER {
		m.parameters, err = amf.AMF3_ReadObjectProperty(r)
		if err != nil {
			return errors.Wrap(err, "failed to read parameters: type map")
		}
	}
	return nil
}
func UnmarshalPlay2Binary(b []byte, encodingAMFType EncodingAMFType) (Play2, error) {
	m := play2{}
	m.SetEncodingAMFType(encodingAMFType)
	err := m.UnmarshalBinary(b)
	return &m, err
}
func (m play2) MarshalLogObject(enc zapcore.ObjectEncoder) error {
	enc.AddString("commandName", m.CommandName())
	enc.AddUint32("transactionID", m.TransactionID())
	if err := enc.AddReflected("commandObject", m.CommandObject()); err != nil {
		return errors.Wrap(err, "failed to AddReflect commandObject")
	}
	if err := enc.AddReflected("parameters", m.Parameters()); err != nil {
		return errors.Wrap(err, "failed to AddReflect parameters")
	}
	enc.AddString("encodingAMFType", m.EncodingAMFType().String())
	return nil
}

type DeleteStream interface {
	encoding.BinaryMarshaler
	zapcore.ObjectMarshaler
	CommandName() string
	TransactionID() uint32
	CommandObject() map[string]interface{}
	StreamID() uint32
	EncodingAMFType() EncodingAMFType
	SetEncodingAMFType(EncodingAMFType)
}

type deleteStream struct {
	streamID        uint32
	encodingAMFType EncodingAMFType
}

func NewDeleteStream(
	streamID uint32,
	encodingAMFType EncodingAMFType,
) DeleteStream {
	return &deleteStream{
		streamID:        streamID,
		encodingAMFType: encodingAMFType,
	}
}

func (m deleteStream) CommandName() string {
	return "deleteStream"
}
func (m deleteStream) TransactionID() uint32 {
	return 0
}
func (m deleteStream) CommandObject() map[string]interface{} {
	return nil
}
func (m deleteStream) StreamID() uint32 {
	return m.streamID
}
func (m deleteStream) EncodingAMFType() EncodingAMFType {
	return m.encodingAMFType
}

func (m *deleteStream) SetEncodingAMFType(v EncodingAMFType) {
	m.encodingAMFType = v
}

func (m deleteStream) MarshalBinary() ([]byte, error) {
	b := new(bytes.Buffer)
	var err error

	if m.EncodingAMFType() == EncodingAMFTypeAMF0 {
		_, err = amf.WriteString(b, m.CommandName())
		if err != nil {
			return nil, errors.Wrap(err, "failed to write commandName: type string")
		}
		_, err = amf.WriteDouble(b, float64(m.TransactionID()))
		if err != nil {
			return nil, errors.Wrap(err, "failed to write transactionID: type uint32")
		}
		if m.CommandObject() == nil {
			_, err = amf.WriteNull(b)
		} else {
			_, err = amf.WriteObject(b, m.CommandObject())
		}
		if err != nil {
			return nil, errors.Wrap(err, "failed to write commandObject: type map")
		}
		_, err = amf.WriteDouble(b, float64(m.StreamID()))
		if err != nil {
			return nil, errors.Wrap(err, "failed to write streamID: type uint32")
		}
		return b.Bytes(), nil
	}

	_, err = amf.AMF3_WriteString(b, m.CommandName())
	if err != nil {
		return nil, errors.Wrap(err, "failed to write commandName: type string")
	}
	_, err = amf.AMF3_WriteDouble(b, float64(m.TransactionID()))
	if err != nil {
		return nil, errors.Wrap(err, "failed to write transactionID: type uint32")
	}
	if m.CommandObject() == nil {
		_, err = amf.AMF3_WriteNull(b)
	} else {
		_, err = amf.AMF3_WriteObject(b, m.CommandObject())
	}
	if err != nil {
		return nil, errors.Wrap(err, "failed to write commandObject: type map")
	}
	_, err = amf.AMF3_WriteDouble(b, float64(m.StreamID()))
	if err != nil {
		return nil, errors.Wrap(err, "failed to write streamID: type uint32")
	}
	return b.Bytes(), nil
}

func (m *deleteStream) UnmarshalBinary(b []byte) error {
	r := bytes.NewReader(b)
	var err error

	if m.EncodingAMFType() == EncodingAMFTypeAMF0 {
		_, err = amf.ReadString(r)
		if err != nil {
			return errors.Wrap(err, "failed to read commandName: type string")
		}
		_, err = amf.ReadDouble(r)
		if err != nil {
			return errors.Wrap(err, "failed to read transactionID: type uint32")
		}
		_, err = amf.ReadMarker(r)
		if err != nil {
			return errors.Wrap(err, "failed to read commandObject: type map")
		}
		if f, err := amf.ReadDouble(r); err != nil {
			return errors.Wrap(err, "failed to read streamID: type uint32")
		} else {
			m.streamID = uint32(f)
		}
		return nil
	}

	_, err = amf.AMF3_ReadString(r)
	if err != nil {
		return errors.Wrap(err, "failed to read commandName: type string")
	}
	_, err = amf.AMF3_ReadDouble(r)
	if err != nil {
		return errors.Wrap(err, "failed to read transactionID: type uint32")
	}
	_, err = amf.ReadMarker(r)
	if err != nil {
		return errors.Wrap(err, "failed to read commandObject: type map")
	}
	if f, err := amf.AMF3_ReadDouble(r); err != nil {
		return errors.Wrap(err, "failed to read streamID: type uint32")
	} else {
		m.streamID = uint32(f)
	}
	return nil
}
func UnmarshalDeleteStreamBinary(b []byte, encodingAMFType EncodingAMFType) (DeleteStream, error) {
	m := deleteStream{}
	m.SetEncodingAMFType(encodingAMFType)
	err := m.UnmarshalBinary(b)
	return &m, err
}
func (m deleteStream) MarshalLogObject(enc zapcore.ObjectEncoder) error {
	enc.AddString("commandName", m.CommandName())
	enc.AddUint32("transactionID", m.TransactionID())
	if err := enc.AddReflected("commandObject", m.CommandObject()); err != nil {
		return errors.Wrap(err, "failed to AddReflect commandObject")
	}
	enc.AddUint32("streamID", m.StreamID())
	enc.AddString("encodingAMFType", m.EncodingAMFType().String())
	return nil
}

type CloseStream interface {
	encoding.BinaryMarshaler
	zapcore.ObjectMarshaler
	CommandName() string
	TransactionID() uint32
	CommandObject() map[string]interface{}
	StreamID() uint32
	EncodingAMFType() EncodingAMFType
	SetEncodingAMFType(EncodingAMFType)
}

type closeStream struct {
	streamID        uint32
	encodingAMFType EncodingAMFType
}

func NewCloseStream(
	streamID uint32,
	encodingAMFType EncodingAMFType,
) CloseStream {
	return &closeStream{
		streamID:        streamID,
		encodingAMFType: encodingAMFType,
	}
}

func (m closeStream) CommandName() string {
	return "closeStream"
}
func (m closeStream) TransactionID() uint32 {
	return 0
}
func (m closeStream) CommandObject() map[string]interface{} {
	return nil
}
func (m closeStream) StreamID() uint32 {
	return m.streamID
}
func (m closeStream) EncodingAMFType() EncodingAMFType {
	return m.encodingAMFType
}

func (m *closeStream) SetEncodingAMFType(v EncodingAMFType) {
	m.encodingAMFType = v
}

func (m closeStream) MarshalBinary() ([]byte, error) {
	b := new(bytes.Buffer)
	var err error

	if m.EncodingAMFType() == EncodingAMFTypeAMF0 {
		_, err = amf.WriteString(b, m.CommandName())
		if err != nil {
			return nil, errors.Wrap(err, "failed to write commandName: type string")
		}
		_, err = amf.WriteDouble(b, float64(m.TransactionID()))
		if err != nil {
			return nil, errors.Wrap(err, "failed to write transactionID: type uint32")
		}
		if m.CommandObject() == nil {
			_, err = amf.WriteNull(b)
		} else {
			_, err = amf.WriteObject(b, m.CommandObject())
		}
		if err != nil {
			return nil, errors.Wrap(err, "failed to write commandObject: type map")
		}
		_, err = amf.WriteDouble(b, float64(m.StreamID()))
		if err != nil {
			return nil, errors.Wrap(err, "failed to write streamID: type uint32")
		}
		return b.Bytes(), nil
	}

	_, err = amf.AMF3_WriteString(b, m.CommandName())
	if err != nil {
		return nil, errors.Wrap(err, "failed to write commandName: type string")
	}
	_, err = amf.AMF3_WriteDouble(b, float64(m.TransactionID()))
	if err != nil {
		return nil, errors.Wrap(err, "failed to write transactionID: type uint32")
	}
	if m.CommandObject() == nil {
		_, err = amf.AMF3_WriteNull(b)
	} else {
		_, err = amf.AMF3_WriteObject(b, m.CommandObject())
	}
	if err != nil {
		return nil, errors.Wrap(err, "failed to write commandObject: type map")
	}
	_, err = amf.AMF3_WriteDouble(b, float64(m.StreamID()))
	if err != nil {
		return nil, errors.Wrap(err, "failed to write streamID: type uint32")
	}
	return b.Bytes(), nil
}

func (m *closeStream) UnmarshalBinary(b []byte) error {
	r := bytes.NewReader(b)
	var err error

	if m.EncodingAMFType() == EncodingAMFTypeAMF0 {
		_, err = amf.ReadString(r)
		if err != nil {
			return errors.Wrap(err, "failed to read commandName: type string")
		}
		_, err = amf.ReadDouble(r)
		if err != nil {
			return errors.Wrap(err, "failed to read transactionID: type uint32")
		}
		_, err = amf.ReadMarker(r)
		if err != nil {
			return errors.Wrap(err, "failed to read commandObject: type map")
		}
		if f, err := amf.ReadDouble(r); err != nil {
			return errors.Wrap(err, "failed to read streamID: type uint32")
		} else {
			m.streamID = uint32(f)
		}
		return nil
	}

	_, err = amf.AMF3_ReadString(r)
	if err != nil {
		return errors.Wrap(err, "failed to read commandName: type string")
	}
	_, err = amf.AMF3_ReadDouble(r)
	if err != nil {
		return errors.Wrap(err, "failed to read transactionID: type uint32")
	}
	_, err = amf.ReadMarker(r)
	if err != nil {
		return errors.Wrap(err, "failed to read commandObject: type map")
	}
	if f, err := amf.AMF3_ReadDouble(r); err != nil {
		return errors.Wrap(err, "failed to read streamID: type uint32")
	} else {
		m.streamID = uint32(f)
	}
	return nil
}
func UnmarshalCloseStreamBinary(b []byte, encodingAMFType EncodingAMFType) (CloseStream, error) {
	m := closeStream{}
	m.SetEncodingAMFType(encodingAMFType)
	err := m.UnmarshalBinary(b)
	return &m, err
}
func (m closeStream) MarshalLogObject(enc zapcore.ObjectEncoder) error {
	enc.AddString("commandName", m.CommandName())
	enc.AddUint32("transactionID", m.TransactionID())
	if err := enc.AddReflected("commandObject", m.CommandObject()); err != nil {
		return errors.Wrap(err, "failed to AddReflect commandObject")
	}
	enc.AddUint32("streamID", m.StreamID())
	enc.AddString("encodingAMFType", m.EncodingAMFType().String())
	return nil
}

type ReceiveAudio interface {
	encoding.BinaryMarshaler
	zapcore.ObjectMarshaler
	CommandName() string
	TransactionID() uint32
	CommandObject() map[string]interface{}
	BoolFlag() bool
	EncodingAMFType() EncodingAMFType
	SetEncodingAMFType(EncodingAMFType)
}

type receiveAudio struct {
	boolFlag        bool
	encodingAMFType EncodingAMFType
}

func NewReceiveAudio(
	boolFlag bool,
	encodingAMFType EncodingAMFType,
) ReceiveAudio {
	return &receiveAudio{
		boolFlag:        boolFlag,
		encodingAMFType: encodingAMFType,
	}
}

func (m receiveAudio) CommandName() string {
	return "receiveAudio"
}
func (m receiveAudio) TransactionID() uint32 {
	return 0
}
func (m receiveAudio) CommandObject() map[string]interface{} {
	return nil
}
func (m receiveAudio) BoolFlag() bool {
	return m.boolFlag
}
func (m receiveAudio) EncodingAMFType() EncodingAMFType {
	return m.encodingAMFType
}

func (m *receiveAudio) SetEncodingAMFType(v EncodingAMFType) {
	m.encodingAMFType = v
}

func (m receiveAudio) MarshalBinary() ([]byte, error) {
	b := new(bytes.Buffer)
	var err error

	if m.EncodingAMFType() == EncodingAMFTypeAMF0 {
		_, err = amf.WriteString(b, m.CommandName())
		if err != nil {
			return nil, errors.Wrap(err, "failed to write commandName: type string")
		}
		_, err = amf.WriteDouble(b, float64(m.TransactionID()))
		if err != nil {
			return nil, errors.Wrap(err, "failed to write transactionID: type uint32")
		}
		if m.CommandObject() == nil {
			_, err = amf.WriteNull(b)
		} else {
			_, err = amf.WriteObject(b, m.CommandObject())
		}
		if err != nil {
			return nil, errors.Wrap(err, "failed to write commandObject: type map")
		}
		_, err = amf.WriteBoolean(b, m.BoolFlag())
		if err != nil {
			return nil, errors.Wrap(err, "failed to write boolFlag: type bool")
		}
		return b.Bytes(), nil
	}

	_, err = amf.AMF3_WriteString(b, m.CommandName())
	if err != nil {
		return nil, errors.Wrap(err, "failed to write commandName: type string")
	}
	_, err = amf.AMF3_WriteDouble(b, float64(m.TransactionID()))
	if err != nil {
		return nil, errors.Wrap(err, "failed to write transactionID: type uint32")
	}
	if m.CommandObject() == nil {
		_, err = amf.AMF3_WriteNull(b)
	} else {
		_, err = amf.AMF3_WriteObject(b, m.CommandObject())
	}
	if err != nil {
		return nil, errors.Wrap(err, "failed to write commandObject: type map")
	}
	_, err = amf.AMF3_WriteBoolean(b, m.BoolFlag())
	if err != nil {
		return nil, errors.Wrap(err, "failed to write boolFlag: type bool")
	}
	return b.Bytes(), nil
}

func (m *receiveAudio) UnmarshalBinary(b []byte) error {
	r := bytes.NewReader(b)
	var err error

	if m.EncodingAMFType() == EncodingAMFTypeAMF0 {
		_, err = amf.ReadString(r)
		if err != nil {
			return errors.Wrap(err, "failed to read commandName: type string")
		}
		_, err = amf.ReadDouble(r)
		if err != nil {
			return errors.Wrap(err, "failed to read transactionID: type uint32")
		}
		_, err = amf.ReadMarker(r)
		if err != nil {
			return errors.Wrap(err, "failed to read commandObject: type map")
		}
		m.boolFlag, err = amf.ReadBoolean(r)
		if err != nil {
			return errors.Wrap(err, "failed to read boolFlag: type bool")
		}
		return nil
	}

	_, err = amf.AMF3_ReadString(r)
	if err != nil {
		return errors.Wrap(err, "failed to read commandName: type string")
	}
	_, err = amf.AMF3_ReadDouble(r)
	if err != nil {
		return errors.Wrap(err, "failed to read transactionID: type uint32")
	}
	_, err = amf.ReadMarker(r)
	if err != nil {
		return errors.Wrap(err, "failed to read commandObject: type map")
	}
	if mk, err := amf.ReadMarker(r); err != nil {
		return errors.Wrap(err, "failed to read boolFlag: type bool")
	} else {
		m.boolFlag = mk == amf.AMF3_TRUE_MARKER
	}
	return nil
}
func UnmarshalReceiveAudioBinary(b []byte, encodingAMFType EncodingAMFType) (ReceiveAudio, error) {
	m := receiveAudio{}
	m.SetEncodingAMFType(encodingAMFType)
	err := m.UnmarshalBinary(b)
	return &m, err
}
func (m receiveAudio) MarshalLogObject(enc zapcore.ObjectEncoder) error {
	enc.AddString("commandName", m.CommandName())
	enc.AddUint32("transactionID", m.TransactionID())
	if err := enc.AddReflected("commandObject", m.CommandObject()); err != nil {
		return errors.Wrap(err, "failed to AddReflect commandObject")
	}
	enc.AddBool("boolFlag", m.BoolFlag())
	enc.AddString("encodingAMFType", m.EncodingAMFType().String())
	return nil
}

type ReceiveVideo interface {
	encoding.BinaryMarshaler
	zapcore.ObjectMarshaler
	CommandName() string
	TransactionID() uint32
	CommandObject() map[string]interface{}
	BoolFlag() bool
	EncodingAMFType() EncodingAMFType
	SetEncodingAMFType(EncodingAMFType)
}

type receiveVideo struct {
	boolFlag        bool
	encodingAMFType EncodingAMFType
}

func NewReceiveVideo(
	boolFlag bool,
	encodingAMFType EncodingAMFType,
) ReceiveVideo {
	return &receiveVideo{
		boolFlag:        boolFlag,
		encodingAMFType: encodingAMFType,
	}
}

func (m receiveVideo) CommandName() string {
	return "receiveVideo"
}
func (m receiveVideo) TransactionID() uint32 {
	return 0
}
func (m receiveVideo) CommandObject() map[string]interface{} {
	return nil
}
func (m receiveVideo) BoolFlag() bool {
	return m.boolFlag
}
func (m receiveVideo) EncodingAMFType() EncodingAMFType {
	return m.encodingAMFType
}

func (m *receiveVideo) SetEncodingAMFType(v EncodingAMFType) {
	m.encodingAMFType = v
}

func (m receiveVideo) MarshalBinary() ([]byte, error) {
	b := new(bytes.Buffer)
	var err error

	if m.EncodingAMFType() == EncodingAMFTypeAMF0 {
		_, err = amf.WriteString(b, m.CommandName())
		if err != nil {
			return nil, errors.Wrap(err, "failed to write commandName: type string")
		}
		_, err = amf.WriteDouble(b, float64(m.TransactionID()))
		if err != nil {
			return nil, errors.Wrap(err, "failed to write transactionID: type uint32")
		}
		if m.CommandObject() == nil {
			_, err = amf.WriteNull(b)
		} else {
			_, err = amf.WriteObject(b, m.CommandObject())
		}
		if err != nil {
			return nil, errors.Wrap(err, "failed to write commandObject: type map")
		}
		_, err = amf.WriteBoolean(b, m.BoolFlag())
		if err != nil {
			return nil, errors.Wrap(err, "failed to write boolFlag: type bool")
		}
		return b.Bytes(), nil
	}

	_, err = amf.AMF3_WriteString(b, m.CommandName())
	if err != nil {
		return nil, errors.Wrap(err, "failed to write commandName: type string")
	}
	_, err = amf.AMF3_WriteDouble(b, float64(m.TransactionID()))
	if err != nil {
		return nil, errors.Wrap(err, "failed to write transactionID: type uint32")
	}
	if m.CommandObject() == nil {
		_, err = amf.AMF3_WriteNull(b)
	} else {
		_, err = amf.AMF3_WriteObject(b, m.CommandObject())
	}
	if err != nil {
		return nil, errors.Wrap(err, "failed to write commandObject: type map")
	}
	_, err = amf.AMF3_WriteBoolean(b, m.BoolFlag())
	if err != nil {
		return nil, errors.Wrap(err, "failed to write boolFlag: type bool")
	}
	return b.Bytes(), nil
}

func (m *receiveVideo) UnmarshalBinary(b []byte) error {
	r := bytes.NewReader(b)
	var err error

	if m.EncodingAMFType() == EncodingAMFTypeAMF0 {
		_, err = amf.ReadString(r)
		if err != nil {
			return errors.Wrap(err, "failed to read commandName: type string")
		}
		_, err = amf.ReadDouble(r)
		if err != nil {
			return errors.Wrap(err, "failed to read transactionID: type uint32")
		}
		_, err = amf.ReadMarker(r)
		if err != nil {
			return errors.Wrap(err, "failed to read commandObject: type map")
		}
		m.boolFlag, err = amf.ReadBoolean(r)
		if err != nil {
			return errors.Wrap(err, "failed to read boolFlag: type bool")
		}
		return nil
	}

	_, err = amf.AMF3_ReadString(r)
	if err != nil {
		return errors.Wrap(err, "failed to read commandName: type string")
	}
	_, err = amf.AMF3_ReadDouble(r)
	if err != nil {
		return errors.Wrap(err, "failed to read transactionID: type uint32")
	}
	_, err = amf.ReadMarker(r)
	if err != nil {
		return errors.Wrap(err, "failed to read commandObject: type map")
	}
	if mk, err := amf.ReadMarker(r); err != nil {
		return errors.Wrap(err, "failed to read boolFlag: type bool")
	} else {
		m.boolFlag = mk == amf.AMF3_TRUE_MARKER
	}
	return nil
}
func UnmarshalReceiveVideoBinary(b []byte, encodingAMFType EncodingAMFType) (ReceiveVideo, error) {
	m := receiveVideo{}
	m.SetEncodingAMFType(encodingAMFType)
	err := m.UnmarshalBinary(b)
	return &m, err
}
func (m receiveVideo) MarshalLogObject(enc zapcore.ObjectEncoder) error {
	enc.AddString("commandName", m.CommandName())
	enc.AddUint32("transactionID", m.TransactionID())
	if err := enc.AddReflected("commandObject", m.CommandObject()); err != nil {
		return errors.Wrap(err, "failed to AddReflect commandObject")
	}
	enc.AddBool("boolFlag", m.BoolFlag())
	enc.AddString("encodingAMFType", m.EncodingAMFType().String())
	return nil
}

type Publish interface {
	encoding.BinaryMarshaler
	zapcore.ObjectMarshaler
	CommandName() string
	TransactionID() uint32
	CommandObject() map[string]interface{}
	PublishingName() string
	PublishingType() PublishingType
	EncodingAMFType() EncodingAMFType
	SetEncodingAMFType(EncodingAMFType)
}

type publish struct {
	publishingName  string
	publishingType  PublishingType
	encodingAMFType EncodingAMFType
}

func NewPublish(
	publishingName string,
	publishingType PublishingType,
	encodingAMFType EncodingAMFType,
) Publish {
	return &publish{
		publishingName:  publishingName,
		publishingType:  publishingType,
		encodingAMFType: encodingAMFType,
	}
}

func (m publish) CommandName() string {
	return "publish"
}
func (m publish) TransactionID() uint32 {
	return 0
}
func (m publish) CommandObject() map[string]interface{} {
	return nil
}
func (m publish) PublishingName() string {
	return m.publishingName
}
func (m publish) PublishingType() PublishingType {
	return m.publishingType
}
func (m publish) EncodingAMFType() EncodingAMFType {
	return m.encodingAMFType
}

func (m *publish) SetEncodingAMFType(v EncodingAMFType) {
	m.encodingAMFType = v
}

func (m publish) MarshalBinary() ([]byte, error) {
	b := new(bytes.Buffer)
	var err error

	if m.EncodingAMFType() == EncodingAMFTypeAMF0 {
		_, err = amf.WriteString(b, m.CommandName())
		if err != nil {
			return nil, errors.Wrap(err, "failed to write commandName: type string")
		}
		_, err = amf.WriteDouble(b, float64(m.TransactionID()))
		if err != nil {
			return nil, errors.Wrap(err, "failed to write transactionID: type uint32")
		}
		if m.CommandObject() == nil {
			_, err = amf.WriteNull(b)
		} else {
			_, err = amf.WriteObject(b, m.CommandObject())
		}
		if err != nil {
			return nil, errors.Wrap(err, "failed to write commandObject: type map")
		}
		_, err = amf.WriteString(b, m.PublishingName())
		if err != nil {
			return nil, errors.Wrap(err, "failed to write publishingName: type string")
		}
		_, err = amf.WriteString(b, string(m.PublishingType()))
		if err != nil {
			return nil, errors.Wrap(err, "failed to write publishingType: type publishingType")
		}
		return b.Bytes(), nil
	}

	_, err = amf.AMF3_WriteString(b, m.CommandName())
	if err != nil {
		return nil, errors.Wrap(err, "failed to write commandName: type string")
	}
	_, err = amf.AMF3_WriteDouble(b, float64(m.TransactionID()))
	if err != nil {
		return nil, errors.Wrap(err, "failed to write transactionID: type uint32")
	}
	if m.CommandObject() == nil {
		_, err = amf.AMF3_WriteNull(b)
	} else {
		_, err = amf.AMF3_WriteObject(b, m.CommandObject())
	}
	if err != nil {
		return nil, errors.Wrap(err, "failed to write commandObject: type map")
	}
	_, err = amf.AMF3_WriteString(b, m.PublishingName())
	if err != nil {
		return nil, errors.Wrap(err, "failed to write publishingName: type string")
	}
	_, err = amf.AMF3_WriteString(b, string(m.PublishingType()))
	if err != nil {
		return nil, errors.Wrap(err, "failed to write publishingType: type publishingType")
	}
	return b.Bytes(), nil
}

func (m *publish) UnmarshalBinary(b []byte) error {
	r := bytes.NewReader(b)
	var err error

	if m.EncodingAMFType() == EncodingAMFTypeAMF0 {
		_, err = amf.ReadString(r)
		if err != nil {
			return errors.Wrap(err, "failed to read commandName: type string")
		}
		_, err = amf.ReadDouble(r)
		if err != nil {
			return errors.Wrap(err, "failed to read transactionID: type uint32")
		}
		_, err = amf.ReadMarker(r)
		if err != nil {
			return errors.Wrap(err, "failed to read commandObject: type map")
		}
		m.publishingName, err = amf.ReadString(r)
		if err != nil {
			return errors.Wrap(err, "failed to read publishingName: type string")
		}
		if f, err := amf.ReadString(r); err != nil {
			return errors.Wrap(err, "failed to read publishingType: type publishingType")
		} else {
			m.publishingType = PublishingType(f)
		}
		return nil
	}

	_, err = amf.AMF3_ReadString(r)
	if err != nil {
		return errors.Wrap(err, "failed to read commandName: type string")
	}
	_, err = amf.AMF3_ReadDouble(r)
	if err != nil {
		return errors.Wrap(err, "failed to read transactionID: type uint32")
	}
	_, err = amf.ReadMarker(r)
	if err != nil {
		return errors.Wrap(err, "failed to read commandObject: type map")
	}
	m.publishingName, err = amf.AMF3_ReadString(r)
	if err != nil {
		return errors.Wrap(err, "failed to read publishingName: type string")
	}
	if f, err := amf.AMF3_ReadString(r); err != nil {
		return errors.Wrap(err, "failed to read publishingType: type publishingType")
	} else {
		m.publishingType = PublishingType(f)
	}
	if err != nil {
		return errors.Wrap(err, "failed to read publishingType: type publishingType")
	}
	return nil
}
func UnmarshalPublishBinary(b []byte, encodingAMFType EncodingAMFType) (Publish, error) {
	m := publish{}
	m.SetEncodingAMFType(encodingAMFType)
	err := m.UnmarshalBinary(b)
	return &m, err
}
func (m publish) MarshalLogObject(enc zapcore.ObjectEncoder) error {
	enc.AddString("commandName", m.CommandName())
	enc.AddUint32("transactionID", m.TransactionID())
	if err := enc.AddReflected("commandObject", m.CommandObject()); err != nil {
		return errors.Wrap(err, "failed to AddReflect commandObject")
	}
	enc.AddString("publishingName", m.PublishingName())
	enc.AddString("publishingType", string(m.PublishingType()))
	enc.AddString("encodingAMFType", m.EncodingAMFType().String())
	return nil
}

type Seek interface {
	encoding.BinaryMarshaler
	zapcore.ObjectMarshaler
	CommandName() string
	TransactionID() uint32
	CommandObject() map[string]interface{}
	MilliSeconds() uint32
	EncodingAMFType() EncodingAMFType
	SetEncodingAMFType(EncodingAMFType)
}

type seek struct {
	milliSeconds    uint32
	encodingAMFType EncodingAMFType
}

func NewSeek(
	milliSeconds uint32,
	encodingAMFType EncodingAMFType,
) Seek {
	return &seek{
		milliSeconds:    milliSeconds,
		encodingAMFType: encodingAMFType,
	}
}

func (m seek) CommandName() string {
	return "seek"
}
func (m seek) TransactionID() uint32 {
	return 0
}
func (m seek) CommandObject() map[string]interface{} {
	return nil
}
func (m seek) MilliSeconds() uint32 {
	return m.milliSeconds
}
func (m seek) EncodingAMFType() EncodingAMFType {
	return m.encodingAMFType
}

func (m *seek) SetEncodingAMFType(v EncodingAMFType) {
	m.encodingAMFType = v
}

func (m seek) MarshalBinary() ([]byte, error) {
	b := new(bytes.Buffer)
	var err error

	if m.EncodingAMFType() == EncodingAMFTypeAMF0 {
		_, err = amf.WriteString(b, m.CommandName())
		if err != nil {
			return nil, errors.Wrap(err, "failed to write commandName: type string")
		}
		_, err = amf.WriteDouble(b, float64(m.TransactionID()))
		if err != nil {
			return nil, errors.Wrap(err, "failed to write transactionID: type uint32")
		}
		if m.CommandObject() == nil {
			_, err = amf.WriteNull(b)
		} else {
			_, err = amf.WriteObject(b, m.CommandObject())
		}
		if err != nil {
			return nil, errors.Wrap(err, "failed to write commandObject: type map")
		}
		_, err = amf.WriteDouble(b, float64(m.MilliSeconds()))
		if err != nil {
			return nil, errors.Wrap(err, "failed to write milliSeconds: type uint32")
		}
		return b.Bytes(), nil
	}

	_, err = amf.AMF3_WriteString(b, m.CommandName())
	if err != nil {
		return nil, errors.Wrap(err, "failed to write commandName: type string")
	}
	_, err = amf.AMF3_WriteDouble(b, float64(m.TransactionID()))
	if err != nil {
		return nil, errors.Wrap(err, "failed to write transactionID: type uint32")
	}
	if m.CommandObject() == nil {
		_, err = amf.AMF3_WriteNull(b)
	} else {
		_, err = amf.AMF3_WriteObject(b, m.CommandObject())
	}
	if err != nil {
		return nil, errors.Wrap(err, "failed to write commandObject: type map")
	}
	_, err = amf.AMF3_WriteDouble(b, float64(m.MilliSeconds()))
	if err != nil {
		return nil, errors.Wrap(err, "failed to write milliSeconds: type uint32")
	}
	return b.Bytes(), nil
}

func (m *seek) UnmarshalBinary(b []byte) error {
	r := bytes.NewReader(b)
	var err error

	if m.EncodingAMFType() == EncodingAMFTypeAMF0 {
		_, err = amf.ReadString(r)
		if err != nil {
			return errors.Wrap(err, "failed to read commandName: type string")
		}
		_, err = amf.ReadDouble(r)
		if err != nil {
			return errors.Wrap(err, "failed to read transactionID: type uint32")
		}
		_, err = amf.ReadMarker(r)
		if err != nil {
			return errors.Wrap(err, "failed to read commandObject: type map")
		}
		if f, err := amf.ReadDouble(r); err != nil {
			return errors.Wrap(err, "failed to read milliSeconds: type uint32")
		} else {
			m.milliSeconds = uint32(f)
		}
		return nil
	}

	_, err = amf.AMF3_ReadString(r)
	if err != nil {
		return errors.Wrap(err, "failed to read commandName: type string")
	}
	_, err = amf.AMF3_ReadDouble(r)
	if err != nil {
		return errors.Wrap(err, "failed to read transactionID: type uint32")
	}
	_, err = amf.ReadMarker(r)
	if err != nil {
		return errors.Wrap(err, "failed to read commandObject: type map")
	}
	if f, err := amf.AMF3_ReadDouble(r); err != nil {
		return errors.Wrap(err, "failed to read milliSeconds: type uint32")
	} else {
		m.milliSeconds = uint32(f)
	}
	return nil
}
func UnmarshalSeekBinary(b []byte, encodingAMFType EncodingAMFType) (Seek, error) {
	m := seek{}
	m.SetEncodingAMFType(encodingAMFType)
	err := m.UnmarshalBinary(b)
	return &m, err
}
func (m seek) MarshalLogObject(enc zapcore.ObjectEncoder) error {
	enc.AddString("commandName", m.CommandName())
	enc.AddUint32("transactionID", m.TransactionID())
	if err := enc.AddReflected("commandObject", m.CommandObject()); err != nil {
		return errors.Wrap(err, "failed to AddReflect commandObject")
	}
	enc.AddUint32("milliSeconds", m.MilliSeconds())
	enc.AddString("encodingAMFType", m.EncodingAMFType().String())
	return nil
}

type Pause interface {
	encoding.BinaryMarshaler
	zapcore.ObjectMarshaler
	CommandName() string
	TransactionID() uint32
	CommandObject() map[string]interface{}
	PauseUnpauseFlag() bool
	MilliSeconds() uint32
	EncodingAMFType() EncodingAMFType
	SetEncodingAMFType(EncodingAMFType)
}

type pause struct {
	pauseUnpauseFlag bool
	milliSeconds     uint32
	encodingAMFType  EncodingAMFType
}

func NewPause(
	pauseUnpauseFlag bool,
	milliSeconds uint32,
	encodingAMFType EncodingAMFType,
) Pause {
	return &pause{
		pauseUnpauseFlag: pauseUnpauseFlag,
		milliSeconds:     milliSeconds,
		encodingAMFType:  encodingAMFType,
	}
}

func (m pause) CommandName() string {
	return "pause"
}
func (m pause) TransactionID() uint32 {
	return 0
}
func (m pause) CommandObject() map[string]interface{} {
	return nil
}
func (m pause) PauseUnpauseFlag() bool {
	return m.pauseUnpauseFlag
}
func (m pause) MilliSeconds() uint32 {
	return m.milliSeconds
}
func (m pause) EncodingAMFType() EncodingAMFType {
	return m.encodingAMFType
}

func (m *pause) SetEncodingAMFType(v EncodingAMFType) {
	m.encodingAMFType = v
}

func (m pause) MarshalBinary() ([]byte, error) {
	b := new(bytes.Buffer)
	var err error

	if m.EncodingAMFType() == EncodingAMFTypeAMF0 {
		_, err = amf.WriteString(b, m.CommandName())
		if err != nil {
			return nil, errors.Wrap(err, "failed to write commandName: type string")
		}
		_, err = amf.WriteDouble(b, float64(m.TransactionID()))
		if err != nil {
			return nil, errors.Wrap(err, "failed to write transactionID: type uint32")
		}
		if m.CommandObject() == nil {
			_, err = amf.WriteNull(b)
		} else {
			_, err = amf.WriteObject(b, m.CommandObject())
		}
		if err != nil {
			return nil, errors.Wrap(err, "failed to write commandObject: type map")
		}
		_, err = amf.WriteBoolean(b, m.PauseUnpauseFlag())
		if err != nil {
			return nil, errors.Wrap(err, "failed to write pauseUnpauseFlag: type bool")
		}
		_, err = amf.WriteDouble(b, float64(m.MilliSeconds()))
		if err != nil {
			return nil, errors.Wrap(err, "failed to write milliSeconds: type uint32")
		}
		return b.Bytes(), nil
	}

	_, err = amf.AMF3_WriteString(b, m.CommandName())
	if err != nil {
		return nil, errors.Wrap(err, "failed to write commandName: type string")
	}
	_, err = amf.AMF3_WriteDouble(b, float64(m.TransactionID()))
	if err != nil {
		return nil, errors.Wrap(err, "failed to write transactionID: type uint32")
	}
	if m.CommandObject() == nil {
		_, err = amf.AMF3_WriteNull(b)
	} else {
		_, err = amf.AMF3_WriteObject(b, m.CommandObject())
	}
	if err != nil {
		return nil, errors.Wrap(err, "failed to write commandObject: type map")
	}
	_, err = amf.AMF3_WriteBoolean(b, m.PauseUnpauseFlag())
	if err != nil {
		return nil, errors.Wrap(err, "failed to write pauseUnpauseFlag: type bool")
	}
	_, err = amf.AMF3_WriteDouble(b, float64(m.MilliSeconds()))
	if err != nil {
		return nil, errors.Wrap(err, "failed to write milliSeconds: type uint32")
	}
	return b.Bytes(), nil
}

func (m *pause) UnmarshalBinary(b []byte) error {
	r := bytes.NewReader(b)
	var err error

	if m.EncodingAMFType() == EncodingAMFTypeAMF0 {
		_, err = amf.ReadString(r)
		if err != nil {
			return errors.Wrap(err, "failed to read commandName: type string")
		}
		_, err = amf.ReadDouble(r)
		if err != nil {
			return errors.Wrap(err, "failed to read transactionID: type uint32")
		}
		_, err = amf.ReadMarker(r)
		if err != nil {
			return errors.Wrap(err, "failed to read commandObject: type map")
		}
		m.pauseUnpauseFlag, err = amf.ReadBoolean(r)
		if err != nil {
			return errors.Wrap(err, "failed to read pauseUnpauseFlag: type bool")
		}
		if f, err := amf.ReadDouble(r); err != nil {
			return errors.Wrap(err, "failed to read milliSeconds: type uint32")
		} else {
			m.milliSeconds = uint32(f)
		}
		return nil
	}

	_, err = amf.AMF3_ReadString(r)
	if err != nil {
		return errors.Wrap(err, "failed to read commandName: type string")
	}
	_, err = amf.AMF3_ReadDouble(r)
	if err != nil {
		return errors.Wrap(err, "failed to read transactionID: type uint32")
	}
	_, err = amf.ReadMarker(r)
	if err != nil {
		return errors.Wrap(err, "failed to read commandObject: type map")
	}
	if mk, err := amf.ReadMarker(r); err != nil {
		return errors.Wrap(err, "failed to read pauseUnpauseFlag: type bool")
	} else {
		m.pauseUnpauseFlag = mk == amf.AMF3_TRUE_MARKER
	}
	if f, err := amf.AMF3_ReadDouble(r); err != nil {
		return errors.Wrap(err, "failed to read milliSeconds: type uint32")
	} else {
		m.milliSeconds = uint32(f)
	}
	return nil
}
func UnmarshalPauseBinary(b []byte, encodingAMFType EncodingAMFType) (Pause, error) {
	m := pause{}
	m.SetEncodingAMFType(encodingAMFType)
	err := m.UnmarshalBinary(b)
	return &m, err
}
func (m pause) MarshalLogObject(enc zapcore.ObjectEncoder) error {
	enc.AddString("commandName", m.CommandName())
	enc.AddUint32("transactionID", m.TransactionID())
	if err := enc.AddReflected("commandObject", m.CommandObject()); err != nil {
		return errors.Wrap(err, "failed to AddReflect commandObject")
	}
	enc.AddBool("pauseUnpauseFlag", m.PauseUnpauseFlag())
	enc.AddUint32("milliSeconds", m.MilliSeconds())
	enc.AddString("encodingAMFType", m.EncodingAMFType().String())
	return nil
}
